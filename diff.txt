diff --git a/Cargo.lock b/Cargo.lock
index 370f074..fef868a 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2,55 +2,12 @@
 # It is not intended for manual editing.
 version = 4
 
-[[package]]
-name = "aho-corasick"
-version = "1.1.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
-dependencies = [
- "memchr",
-]
-
 [[package]]
 name = "allocator-api2"
 version = "0.2.21"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"
 
-[[package]]
-name = "alsa"
-version = "0.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed7572b7ba83a31e20d1b48970ee402d2e3e0537dcfe0a3ff4d6eb7508617d43"
-dependencies = [
- "alsa-sys",
- "bitflags 2.9.1",
- "cfg-if",
- "libc",
-]
-
-[[package]]
-name = "alsa-sys"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "db8fee663d06c4e303404ef5f40488a53e062f89ba8bfed81f42325aafad1527"
-dependencies = [
- "libc",
- "pkg-config",
-]
-
-[[package]]
-name = "anes"
-version = "0.1.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4b46cbb362ab8752921c97e041f5e366ee6297bd428a31275b9fcf1e380f7299"
-
-[[package]]
-name = "anstyle"
-version = "1.0.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"
-
 [[package]]
 name = "arc-swap"
 version = "1.7.1"
@@ -63,252 +20,12 @@ version = "1.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "55ca83137a482d61d916ceb1eba52a684f98004f18e0cafea230fe5579c178a3"
 
-[[package]]
-name = "autocfg"
-version = "1.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"
-
-[[package]]
-name = "bitflags"
-version = "1.3.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
-
-[[package]]
-name = "bitflags"
-version = "2.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1b8e56985ec62d17e9c1001dc89c88ecd7dc08e47eba5ec7c29c7b5eeecde967"
-
-[[package]]
-name = "bumpalo"
-version = "3.18.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "793db76d6187cd04dff33004d8e6c9cc4e05cd330500379d2394209271b4aeee"
-
 [[package]]
 name = "byteorder"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"
 
-[[package]]
-name = "bytes"
-version = "1.10.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"
-
-[[package]]
-name = "cast"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"
-
-[[package]]
-name = "cesu8"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"
-
-[[package]]
-name = "cfg-if"
-version = "1.0.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9555578bc9e57714c812a1f84e4fc5b4d21fcb063490c624de019f7464c91268"
-
-[[package]]
-name = "ciborium"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "42e69ffd6f0917f5c029256a24d0161db17cea3997d185db0d35926308770f0e"
-dependencies = [
- "ciborium-io",
- "ciborium-ll",
- "serde",
-]
-
-[[package]]
-name = "ciborium-io"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05afea1e0a06c9be33d539b876f1ce3692f4afea2cb41f740e7743225ed1c757"
-
-[[package]]
-name = "ciborium-ll"
-version = "0.2.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "57663b653d948a338bfb3eeba9bb2fd5fcfaecb9e199e87e1eda4d9e8b240fd9"
-dependencies = [
- "ciborium-io",
- "half",
-]
-
-[[package]]
-name = "clap"
-version = "4.5.40"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "40b6887a1d8685cebccf115538db5c0efe625ccac9696ad45c409d96566e910f"
-dependencies = [
- "clap_builder",
-]
-
-[[package]]
-name = "clap_builder"
-version = "4.5.40"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e0c66c08ce9f0c698cbce5c0279d0bb6ac936d8674174fe48f736533b964f59e"
-dependencies = [
- "anstyle",
- "clap_lex",
-]
-
-[[package]]
-name = "clap_lex"
-version = "0.7.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"
-
-[[package]]
-name = "combine"
-version = "4.6.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ba5a308b75df32fe02788e748662718f03fde005016435c444eea572398219fd"
-dependencies = [
- "bytes",
- "memchr",
-]
-
-[[package]]
-name = "coreaudio-rs"
-version = "0.13.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1aae284fbaf7d27aa0e292f7677dfbe26503b0d555026f702940805a630eac17"
-dependencies = [
- "bitflags 1.3.2",
- "libc",
- "objc2-audio-toolbox",
- "objc2-core-audio",
- "objc2-core-audio-types",
- "objc2-core-foundation",
-]
-
-[[package]]
-name = "cpal"
-version = "0.16.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cbd307f43cc2a697e2d1f8bc7a1d824b5269e052209e28883e5bc04d095aaa3f"
-dependencies = [
- "alsa",
- "coreaudio-rs",
- "dasp_sample",
- "jack",
- "jni",
- "js-sys",
- "libc",
- "mach2",
- "ndk",
- "ndk-context",
- "num-derive",
- "num-traits",
- "objc2-audio-toolbox",
- "objc2-core-audio",
- "objc2-core-audio-types",
- "wasm-bindgen",
- "wasm-bindgen-futures",
- "web-sys",
- "windows",
-]
-
-[[package]]
-name = "criterion"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f2b12d017a929603d80db1831cd3a24082f8137ce19c69e6447f54f5fc8d692f"
-dependencies = [
- "anes",
- "cast",
- "ciborium",
- "clap",
- "criterion-plot",
- "is-terminal",
- "itertools",
- "num-traits",
- "once_cell",
- "oorandom",
- "plotters",
- "rayon",
- "regex",
- "serde",
- "serde_derive",
- "serde_json",
- "tinytemplate",
- "walkdir",
-]
-
-[[package]]
-name = "criterion-plot"
-version = "0.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6b50826342786a51a89e2da3a28f1c32b06e387201bc2d19791f622c673706b1"
-dependencies = [
- "cast",
- "itertools",
-]
-
-[[package]]
-name = "crossbeam-deque"
-version = "0.8.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
-dependencies = [
- "crossbeam-epoch",
- "crossbeam-utils",
-]
-
-[[package]]
-name = "crossbeam-epoch"
-version = "0.9.18"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
-dependencies = [
- "crossbeam-utils",
-]
-
-[[package]]
-name = "crossbeam-utils"
-version = "0.8.21"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"
-
-[[package]]
-name = "crunchy"
-version = "0.2.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "43da5946c66ffcc7745f48db692ffbb10a83bfe0afd96235c5c2a4fb23994929"
-
-[[package]]
-name = "dasp_sample"
-version = "0.11.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0c87e182de0887fd5361989c677c4e8f5000cd9491d6d563161a8f3a5519fc7f"
-
-[[package]]
-name = "dispatch2"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "89a09f22a6c6069a18470eb92d2298acf25463f14256d24778e1230d789a2aec"
-dependencies = [
- "bitflags 2.9.1",
- "objc2",
-]
-
-[[package]]
-name = "either"
-version = "1.15.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"
-
 [[package]]
 name = "equivalent"
 version = "1.0.2"
@@ -321,16 +38,6 @@ version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"
 
-[[package]]
-name = "half"
-version = "2.6.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "459196ed295495a68f7d7fe1d84f6c4b7ff0e21fe3017b2f283c6fac3ad803c9"
-dependencies = [
- "cfg-if",
- "crunchy",
-]
-
 [[package]]
 name = "hash32"
 version = "0.3.1"
@@ -361,12 +68,6 @@ dependencies = [
  "stable_deref_trait",
 ]
 
-[[package]]
-name = "hermit-abi"
-version = "0.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"
-
 [[package]]
 name = "indexmap"
 version = "2.10.0"
@@ -377,182 +78,22 @@ dependencies = [
  "hashbrown",
 ]
 
-[[package]]
-name = "is-terminal"
-version = "0.4.16"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e04d7f318608d35d4b61ddd75cbdaee86b023ebe2bd5a66ee0915f0bf93095a9"
-dependencies = [
- "hermit-abi",
- "libc",
- "windows-sys 0.59.0",
-]
-
-[[package]]
-name = "itertools"
-version = "0.10.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
-dependencies = [
- "either",
-]
-
-[[package]]
-name = "itoa"
-version = "1.0.15"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"
-
-[[package]]
-name = "jack"
-version = "0.13.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f70ca699f44c04a32d419fc9ed699aaea89657fc09014bf3fa238e91d13041b9"
-dependencies = [
- "bitflags 2.9.1",
- "jack-sys",
- "lazy_static",
- "libc",
- "log",
-]
-
-[[package]]
-name = "jack-sys"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6013b7619b95a22b576dfb43296faa4ecbe40abbdb97dfd22ead520775fc86ab"
-dependencies = [
- "bitflags 1.3.2",
- "lazy_static",
- "libc",
- "libloading",
- "log",
- "pkg-config",
-]
-
-[[package]]
-name = "jni"
-version = "0.21.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
-dependencies = [
- "cesu8",
- "cfg-if",
- "combine",
- "jni-sys",
- "log",
- "thiserror",
- "walkdir",
- "windows-sys 0.45.0",
-]
-
-[[package]]
-name = "jni-sys"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"
-
-[[package]]
-name = "js-sys"
-version = "0.3.77"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
-dependencies = [
- "once_cell",
- "wasm-bindgen",
-]
-
-[[package]]
-name = "lazy_static"
-version = "1.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"
-
-[[package]]
-name = "libc"
-version = "0.2.172"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
-
-[[package]]
-name = "libloading"
-version = "0.7.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
-dependencies = [
- "cfg-if",
- "winapi",
-]
-
-[[package]]
-name = "log"
-version = "0.4.27"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"
-
-[[package]]
-name = "mach2"
-version = "0.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "19b955cdeb2a02b9117f121ce63aa52d08ade45de53e48fe6a38b39c10f6f709"
-dependencies = [
- "libc",
-]
-
-[[package]]
-name = "memchr"
-version = "2.7.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
-
 [[package]]
 name = "mini-graph"
 version = "0.1.0"
 dependencies = [
  "arc-swap",
  "assert_no_alloc",
- "cpal",
- "criterion",
  "hashbrown",
  "heapless",
  "indexmap",
+ "mini-graph-macros",
  "portable-atomic",
 ]
 
 [[package]]
-name = "ndk"
-version = "0.9.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c3f42e7bbe13d351b6bead8286a43aac9534b82bd3cc43e47037f012ebfd62d4"
-dependencies = [
- "bitflags 2.9.1",
- "jni-sys",
- "log",
- "ndk-sys",
- "num_enum",
- "thiserror",
-]
-
-[[package]]
-name = "ndk-context"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"
-
-[[package]]
-name = "ndk-sys"
-version = "0.6.0+11769913"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ee6cda3051665f1fb8d9e08fc35c96d5a244fb1be711a03b71118828afc9a873"
-dependencies = [
- "jni-sys",
-]
-
-[[package]]
-name = "num-derive"
-version = "0.4.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
+name = "mini-graph-macros"
+version = "0.1.0"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -560,653 +101,48 @@ dependencies = [
 ]
 
 [[package]]
-name = "num-traits"
-version = "0.2.19"
+name = "portable-atomic"
+version = "1.11.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
-dependencies = [
- "autocfg",
-]
+checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"
 
 [[package]]
-name = "num_enum"
-version = "0.7.3"
+name = "proc-macro2"
+version = "1.0.95"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4e613fc340b2220f734a8595782c551f1250e969d87d3be1ae0579e8d4065179"
+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
 dependencies = [
- "num_enum_derive",
+ "unicode-ident",
 ]
 
 [[package]]
-name = "num_enum_derive"
-version = "0.7.3"
+name = "quote"
+version = "1.0.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "af1844ef2428cc3e1cb900be36181049ef3d3193c63e43026cfe202983b27a56"
+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
 dependencies = [
- "proc-macro-crate",
  "proc-macro2",
- "quote",
- "syn",
-]
-
-[[package]]
-name = "objc2"
-version = "0.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "88c6597e14493ab2e44ce58f2fdecf095a51f12ca57bec060a11c57332520551"
-dependencies = [
- "objc2-encode",
-]
-
-[[package]]
-name = "objc2-audio-toolbox"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "10cbe18d879e20a4aea544f8befe38bcf52255eb63d3f23eca2842f3319e4c07"
-dependencies = [
- "bitflags 2.9.1",
- "libc",
- "objc2",
- "objc2-core-audio",
- "objc2-core-audio-types",
- "objc2-core-foundation",
- "objc2-foundation",
-]
-
-[[package]]
-name = "objc2-core-audio"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ca44961e888e19313b808f23497073e3f6b3c22bb485056674c8b49f3b025c82"
-dependencies = [
- "dispatch2",
- "objc2",
- "objc2-core-audio-types",
- "objc2-core-foundation",
 ]
 
 [[package]]
-name = "objc2-core-audio-types"
-version = "0.3.1"
+name = "stable_deref_trait"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c0f1cc99bb07ad2ddb6527ddf83db6a15271bb036b3eb94b801cd44fdc666ee1"
-dependencies = [
- "bitflags 2.9.1",
- "objc2",
-]
+checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
 
 [[package]]
-name = "objc2-core-foundation"
-version = "0.3.1"
+name = "syn"
+version = "2.0.102"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1c10c2894a6fed806ade6027bcd50662746363a9589d3ec9d9bef30a4e4bc166"
+checksum = "f6397daf94fa90f058bd0fd88429dd9e5738999cca8d701813c80723add80462"
 dependencies = [
- "bitflags 2.9.1",
- "dispatch2",
- "objc2",
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
 ]
 
 [[package]]
-name = "objc2-encode"
-version = "4.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ef25abbcd74fb2609453eb695bd2f860d389e457f67dc17cafc8b8cbc89d0c33"
-
-[[package]]
-name = "objc2-foundation"
-version = "0.3.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "900831247d2fe1a09a683278e5384cfb8c80c79fe6b166f9d14bfdde0ea1b03c"
-dependencies = [
- "objc2",
-]
-
-[[package]]
-name = "once_cell"
-version = "1.21.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
-
-[[package]]
-name = "oorandom"
-version = "11.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d6790f58c7ff633d8771f42965289203411a5e5c68388703c06e14f24770b41e"
-
-[[package]]
-name = "pkg-config"
-version = "0.3.32"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"
-
-[[package]]
-name = "plotters"
-version = "0.3.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5aeb6f403d7a4911efb1e33402027fc44f29b5bf6def3effcc22d7bb75f2b747"
-dependencies = [
- "num-traits",
- "plotters-backend",
- "plotters-svg",
- "wasm-bindgen",
- "web-sys",
-]
-
-[[package]]
-name = "plotters-backend"
-version = "0.3.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "df42e13c12958a16b3f7f4386b9ab1f3e7933914ecea48da7139435263a4172a"
-
-[[package]]
-name = "plotters-svg"
-version = "0.3.7"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "51bae2ac328883f7acdfea3d66a7c35751187f870bc81f94563733a154d7a670"
-dependencies = [
- "plotters-backend",
-]
-
-[[package]]
-name = "portable-atomic"
-version = "1.11.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f84267b20a16ea918e43c6a88433c2d54fa145c92a811b5b047ccbe153674483"
-
-[[package]]
-name = "proc-macro-crate"
-version = "3.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "edce586971a4dfaa28950c6f18ed55e0406c1ab88bbce2c6f6293a7aaba73d35"
-dependencies = [
- "toml_edit",
-]
-
-[[package]]
-name = "proc-macro2"
-version = "1.0.95"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
-dependencies = [
- "unicode-ident",
-]
-
-[[package]]
-name = "quote"
-version = "1.0.40"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
-dependencies = [
- "proc-macro2",
-]
-
-[[package]]
-name = "rayon"
-version = "1.10.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
-dependencies = [
- "either",
- "rayon-core",
-]
-
-[[package]]
-name = "rayon-core"
-version = "1.12.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
-dependencies = [
- "crossbeam-deque",
- "crossbeam-utils",
-]
-
-[[package]]
-name = "regex"
-version = "1.11.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
-dependencies = [
- "aho-corasick",
- "memchr",
- "regex-automata",
- "regex-syntax",
-]
-
-[[package]]
-name = "regex-automata"
-version = "0.4.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
-dependencies = [
- "aho-corasick",
- "memchr",
- "regex-syntax",
-]
-
-[[package]]
-name = "regex-syntax"
-version = "0.8.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"
-
-[[package]]
-name = "rustversion"
-version = "1.0.21"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8a0d197bd2c9dc6e53b84da9556a69ba4cdfab8619eb41a8bd1cc2027a0f6b1d"
-
-[[package]]
-name = "ryu"
-version = "1.0.20"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"
-
-[[package]]
-name = "same-file"
-version = "1.0.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
-dependencies = [
- "winapi-util",
-]
-
-[[package]]
-name = "serde"
-version = "1.0.219"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
-dependencies = [
- "serde_derive",
-]
-
-[[package]]
-name = "serde_derive"
-version = "1.0.219"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
-]
-
-[[package]]
-name = "serde_json"
-version = "1.0.140"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373"
-dependencies = [
- "itoa",
- "memchr",
- "ryu",
- "serde",
-]
-
-[[package]]
-name = "stable_deref_trait"
-version = "1.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"
-
-[[package]]
-name = "syn"
-version = "2.0.102"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f6397daf94fa90f058bd0fd88429dd9e5738999cca8d701813c80723add80462"
-dependencies = [
- "proc-macro2",
- "quote",
- "unicode-ident",
-]
-
-[[package]]
-name = "thiserror"
-version = "1.0.69"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
-dependencies = [
- "thiserror-impl",
-]
-
-[[package]]
-name = "thiserror-impl"
-version = "1.0.69"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
-]
-
-[[package]]
-name = "tinytemplate"
-version = "1.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "be4d6b5f19ff7664e8c98d03e2139cb510db9b0a60b55f8e8709b689d939b6bc"
-dependencies = [
- "serde",
- "serde_json",
-]
-
-[[package]]
-name = "toml_datetime"
-version = "0.6.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"
-
-[[package]]
-name = "toml_edit"
-version = "0.22.27"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
-dependencies = [
- "indexmap",
- "toml_datetime",
- "winnow",
-]
-
-[[package]]
-name = "unicode-ident"
-version = "1.0.18"
+name = "unicode-ident"
+version = "1.0.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"
-
-[[package]]
-name = "walkdir"
-version = "2.5.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
-dependencies = [
- "same-file",
- "winapi-util",
-]
-
-[[package]]
-name = "wasm-bindgen"
-version = "0.2.100"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
-dependencies = [
- "cfg-if",
- "once_cell",
- "rustversion",
- "wasm-bindgen-macro",
-]
-
-[[package]]
-name = "wasm-bindgen-backend"
-version = "0.2.100"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
-dependencies = [
- "bumpalo",
- "log",
- "proc-macro2",
- "quote",
- "syn",
- "wasm-bindgen-shared",
-]
-
-[[package]]
-name = "wasm-bindgen-futures"
-version = "0.4.50"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
-dependencies = [
- "cfg-if",
- "js-sys",
- "once_cell",
- "wasm-bindgen",
- "web-sys",
-]
-
-[[package]]
-name = "wasm-bindgen-macro"
-version = "0.2.100"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
-dependencies = [
- "quote",
- "wasm-bindgen-macro-support",
-]
-
-[[package]]
-name = "wasm-bindgen-macro-support"
-version = "0.2.100"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
- "wasm-bindgen-backend",
- "wasm-bindgen-shared",
-]
-
-[[package]]
-name = "wasm-bindgen-shared"
-version = "0.2.100"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
-dependencies = [
- "unicode-ident",
-]
-
-[[package]]
-name = "web-sys"
-version = "0.3.77"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
-dependencies = [
- "js-sys",
- "wasm-bindgen",
-]
-
-[[package]]
-name = "winapi"
-version = "0.3.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
-dependencies = [
- "winapi-i686-pc-windows-gnu",
- "winapi-x86_64-pc-windows-gnu",
-]
-
-[[package]]
-name = "winapi-i686-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
-
-[[package]]
-name = "winapi-util"
-version = "0.1.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
-dependencies = [
- "windows-sys 0.59.0",
-]
-
-[[package]]
-name = "winapi-x86_64-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
-
-[[package]]
-name = "windows"
-version = "0.54.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9252e5725dbed82865af151df558e754e4a3c2c30818359eb17465f1346a1b49"
-dependencies = [
- "windows-core",
- "windows-targets 0.52.6",
-]
-
-[[package]]
-name = "windows-core"
-version = "0.54.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "12661b9c89351d684a50a8a643ce5f608e20243b9fb84687800163429f161d65"
-dependencies = [
- "windows-result",
- "windows-targets 0.52.6",
-]
-
-[[package]]
-name = "windows-result"
-version = "0.1.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5e383302e8ec8515204254685643de10811af0ed97ea37210dc26fb0032647f8"
-dependencies = [
- "windows-targets 0.52.6",
-]
-
-[[package]]
-name = "windows-sys"
-version = "0.45.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
-dependencies = [
- "windows-targets 0.42.2",
-]
-
-[[package]]
-name = "windows-sys"
-version = "0.59.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
-dependencies = [
- "windows-targets 0.52.6",
-]
-
-[[package]]
-name = "windows-targets"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
-dependencies = [
- "windows_aarch64_gnullvm 0.42.2",
- "windows_aarch64_msvc 0.42.2",
- "windows_i686_gnu 0.42.2",
- "windows_i686_msvc 0.42.2",
- "windows_x86_64_gnu 0.42.2",
- "windows_x86_64_gnullvm 0.42.2",
- "windows_x86_64_msvc 0.42.2",
-]
-
-[[package]]
-name = "windows-targets"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
-dependencies = [
- "windows_aarch64_gnullvm 0.52.6",
- "windows_aarch64_msvc 0.52.6",
- "windows_i686_gnu 0.52.6",
- "windows_i686_gnullvm",
- "windows_i686_msvc 0.52.6",
- "windows_x86_64_gnu 0.52.6",
- "windows_x86_64_gnullvm 0.52.6",
- "windows_x86_64_msvc 0.52.6",
-]
-
-[[package]]
-name = "windows_aarch64_gnullvm"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"
-
-[[package]]
-name = "windows_aarch64_gnullvm"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
-
-[[package]]
-name = "windows_aarch64_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"
-
-[[package]]
-name = "windows_aarch64_msvc"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
-
-[[package]]
-name = "windows_i686_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"
-
-[[package]]
-name = "windows_i686_gnu"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
-
-[[package]]
-name = "windows_i686_gnullvm"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
-
-[[package]]
-name = "windows_i686_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"
-
-[[package]]
-name = "windows_i686_msvc"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
-
-[[package]]
-name = "windows_x86_64_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"
-
-[[package]]
-name = "windows_x86_64_gnu"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
-
-[[package]]
-name = "windows_x86_64_gnullvm"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"
-
-[[package]]
-name = "windows_x86_64_gnullvm"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
-
-[[package]]
-name = "windows_x86_64_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"
-
-[[package]]
-name = "windows_x86_64_msvc"
-version = "0.52.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
-
-[[package]]
-name = "winnow"
-version = "0.7.11"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "74c7b26e3480b707944fc872477815d29a8e429d2f93a1ce000f5fa84a15cbcd"
-dependencies = [
- "memchr",
-]
diff --git a/Cargo.toml b/Cargo.toml
index 84b6b68..0de3cf4 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,25 +1,8 @@
-[package]
-name = "mini-graph"
-version = "0.1.0"
-edition = "2021"
-
-[features]
-default = ["std"]
-std     = []
-
-[dependencies]
-cpal = { version = "0.16.0", features = ["jack"] }
-assert_no_alloc = "1.1.2"
-hashbrown = { version = "0.15.4", features = ["inline-more"] }
-indexmap = "2.10.0"
-heapless = "0.8.0"
-portable-atomic = { version = "1.11.1", features = ["float"] }
-arc-swap = "1.7.1"
-
-
-[dev-dependencies]
-criterion = { version = "0.5", features = ["html_reports"] }
-
-[[bench]]
-name = "multi_tap"
-harness = false
+[workspace]
+members = [
+    "mini-graph",
+    "mini-graph-macros",
+]
+
+[workspace.dependencies]
+criterion = { version = "0.5", features = ["html_reports"] }
\ No newline at end of file
diff --git a/benches/multi_tap.rs b/benches/multi_tap.rs
deleted file mode 100644
index c089562..0000000
--- a/benches/multi_tap.rs
+++ /dev/null
@@ -1,122 +0,0 @@
-use criterion::{criterion_group, criterion_main, Criterion};
-use mini_graph::mini_graph::audio_graph::{DynamicAudioGraph, AudioGraphApi, AddNodeProps};
-use mini_graph::mini_graph::bang::Bang;
-use mini_graph::mini_graph::write::write_data;
-use mini_graph::mini_graph::buffer::Buffer;
-use mini_graph::nodes::audio::osc::Wave;
-
-const CHANNEL_COUNT: usize = 2;
-const FRAME_SIZE: usize = 1024;
-const SAMPLE_RATE: u32 = 48_000;
-
-fn make_full_graph() -> DynamicAudioGraph<FRAME_SIZE, CHANNEL_COUNT> {
-    let mut audio_graph = DynamicAudioGraph::<FRAME_SIZE, CHANNEL_COUNT>::with_capacity(32);
-
-    let clock_one = audio_graph.add_audio_unit(AddNodeProps::Clock {
-        sample_rate: SAMPLE_RATE,
-        rate: std::time::Duration::from_secs_f32(0.5),
-    });
-
-    let clock_two = audio_graph.add_audio_unit(AddNodeProps::Clock {
-        sample_rate: SAMPLE_RATE,
-        rate: std::time::Duration::from_secs_f32(2.0 / 3.0),
-    });
-
-    let iterator_one = audio_graph.add_audio_unit(AddNodeProps::Iter {
-        values: &[Bang::BangF32(440.0 / 2.0), Bang::BangF32(523.251 / 2.0), Bang::BangF32(783.991 / 2.0)],
-    });
-
-    let iterator_two = audio_graph.add_audio_unit(AddNodeProps::Iter {
-        values: &[Bang::BangF32(440.0 * 2.0), Bang::BangF32(523.251 * 2.0), Bang::BangF32(783.991 * 2.0)],
-    });
-
-    let adsr_one = audio_graph.add_audio_unit(AddNodeProps::ADSR {
-        sample_rate: SAMPLE_RATE,
-    });
-
-    let adsr_two = audio_graph.add_audio_unit(AddNodeProps::ADSR {
-        sample_rate: SAMPLE_RATE,
-    });
-
-    let osc_one = audio_graph.add_audio_unit(AddNodeProps::Oscillator {
-        freq: 440.0,
-        sample_rate: SAMPLE_RATE,
-        phase: 0.0,
-        wave: Wave::SawWave,
-    });
-
-    let osc_two = audio_graph.add_audio_unit(AddNodeProps::Oscillator {
-        freq: 440.0,
-        sample_rate: SAMPLE_RATE,
-        phase: 0.0,
-        wave: Wave::SawWave,
-    });
-
-    audio_graph.add_edges(&[
-        (clock_one, iterator_one),
-        (iterator_one, osc_one),
-        (osc_one, adsr_one),
-        (clock_one, adsr_one),
-
-        (clock_two, iterator_two),
-        (iterator_two, osc_two),
-        (osc_two, adsr_two),
-        (clock_two, adsr_two),
-    ]);
-
-    let mixer = audio_graph.add_audio_unit(AddNodeProps::Mixer);
-    audio_graph.add_edges(&[(adsr_one, mixer), (adsr_two, mixer)]);
-
-    let delay_name = "delay_bus";
-    let delay_capacity = (SAMPLE_RATE * 2) as usize;
-
-    let write_one = audio_graph.add_audio_unit(AddNodeProps::DelayWrite {
-        delay_line_name: delay_name,
-        capacity: delay_capacity,
-        name: delay_name,
-    });
-
-    let tap_one = audio_graph.add_audio_unit(AddNodeProps::DelayTap {
-        name: delay_name,
-        sample_offset: (2.0 / 3.0) * SAMPLE_RATE as f32,
-        gain: 0.8,
-    });
-
-    let tap_two = audio_graph.add_audio_unit(AddNodeProps::DelayTap {
-        name: delay_name,
-        sample_offset: 1.0 * SAMPLE_RATE as f32,
-        gain: 0.6,
-    });
-
-    let tap_three = audio_graph.add_audio_unit(AddNodeProps::DelayTap {
-        name: delay_name,
-        sample_offset: (3.0 / 2.0) * SAMPLE_RATE as f32,
-        gain: 0.4,
-    });
-
-    let mixer_two = audio_graph.add_audio_unit(AddNodeProps::Mixer);
-    audio_graph.add_edges(&[
-        (mixer, mixer_two),
-        (mixer, write_one),
-        (tap_one, mixer_two),
-        (tap_two, mixer_two),
-        (tap_three, mixer_two),
-    ]);
-
-    audio_graph.set_sink_index(mixer_two);
-    audio_graph
-}
-
-fn bench_complex_patch(c: &mut Criterion) {
-    let mut graph = make_full_graph();
-    let mut buffer = Buffer::<FRAME_SIZE>::default();
-
-    c.bench_function("complex_audio_patch", |b| {
-        b.iter(|| {
-            write_data(&mut buffer, &mut graph);
-        });
-    });
-}
-
-criterion_group!(benches, bench_complex_patch);
-criterion_main!(benches);
diff --git a/examples/chaining_graphs.rs b/examples/chaining_graphs.rs
deleted file mode 100644
index 7741780..0000000
--- a/examples/chaining_graphs.rs
+++ /dev/null
@@ -1,69 +0,0 @@
-use mini_graph::mini_graph::audio_graph::{AddNodeProps, AudioGraphApi, DynamicAudioGraph};
-use mini_graph::mini_graph::write::write_data;
-use mini_graph::nodes::audio::filters::FilterType;
-use mini_graph::nodes::audio::osc::Wave;
-
-use assert_no_alloc::*;
-use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
-use cpal::{BufferSize, BuildStreamError, FromSample, SampleRate, SizedSample, StreamConfig};
-
-#[cfg(debug_assertions)]
-#[global_allocator]
-static A: AllocDisabler = AllocDisabler;
-
-const SAMPLE_RATE: u32 = 48_000;
-const FRAME_SIZE: usize = 1024;
-const CHANNEL_COUNT: usize = 2;
-
-fn run<T>(device: &cpal::Device, config: &cpal::StreamConfig) -> Result<(), BuildStreamError>
-where
-    T: SizedSample + FromSample<f64>,
-{
-    let mut audio_graph = DynamicAudioGraph::<FRAME_SIZE, CHANNEL_COUNT>::with_capacity(4);
-
-    let osc_id = audio_graph.add_audio_unit(AddNodeProps::Oscillator { freq: 440.0, sample_rate: SAMPLE_RATE, phase: 0.0, wave: Wave::SinWave });
-
-    audio_graph.set_sink_index(osc_id);
-
-    let mut audio_graph_two = DynamicAudioGraph::<FRAME_SIZE, CHANNEL_COUNT>::with_capacity(4);
-
-    let lfo_id = audio_graph_two.add_audio_unit(AddNodeProps::Lfo { freq: 1.0, offset: 2400.0, amp: 1600.0 , phase: 0.0, sample_rate: SAMPLE_RATE as f32});
-
-    let filter_id = audio_graph_two.add_audio_unit(AddNodeProps::Filter { sample_rate: SAMPLE_RATE as f32, filter_type: FilterType::LowPass, cutoff: 2400.0, gain: 0.6, q: 0.3 });
-
-    audio_graph_two.add_edge(lfo_id, filter_id);
-
-    let graph_id = audio_graph_two.add_audio_unit(AddNodeProps::Graph { graph: audio_graph });
-
-    audio_graph_two.add_edge(graph_id, filter_id);
-
-    audio_graph_two.set_sink_index(filter_id);
-
-    // Build CPAL output stream
-    let stream = device.build_output_stream(
-        config,
-        move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
-            assert_no_alloc(|| write_data::<FRAME_SIZE, CHANNEL_COUNT, f32>(data, &mut audio_graph_two))
-        },
-        |err| eprintln!("An output stream error occurred: {}", err),
-        None,
-    )?;
-
-    stream.play().unwrap();
-
-    std::thread::park(); // Keep alive
-    Ok(())
-}
-
-fn main() {
-    let host = cpal::host_from_id(cpal::HostId::Jack).expect("JACK host not available");
-    let device = host.default_output_device().expect("No output device available");
-
-    let config = StreamConfig {
-        channels: CHANNEL_COUNT as u16,
-        sample_rate: SampleRate(SAMPLE_RATE),
-        buffer_size: BufferSize::Fixed(FRAME_SIZE as u32),
-    };
-
-    run::<f32>(&device, &config.into()).unwrap();
-}
diff --git a/examples/load_sample.rs b/examples/load_sample.rs
deleted file mode 100644
index 5ff4962..0000000
--- a/examples/load_sample.rs
+++ /dev/null
@@ -1,65 +0,0 @@
-use mini_graph::{mini_graph::{audio_graph::{AddNodeProps, AudioGraphApi, DynamicAudioGraph}, write::write_data}, nodes::audio::sampler::build_audio_sampler};
-
-
-use assert_no_alloc::*;
-use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
-use cpal::{BufferSize, BuildStreamError, FromSample, SampleRate, SizedSample, StreamConfig};
-
-#[cfg(debug_assertions)]
-#[global_allocator]
-static A: AllocDisabler = AllocDisabler;
-
-const SAMPLE_RATE: u32 = 48_000;
-const FRAME_SIZE: usize = 1024;
-const CHANNEL_COUNT: usize = 2;
-
-
-fn run<T>(device: &cpal::Device, config: &cpal::StreamConfig) -> Result<(), BuildStreamError>
-where
-    T: SizedSample + FromSample<f64> {
-
-    let mut audio_graph = DynamicAudioGraph::<FRAME_SIZE, CHANNEL_COUNT>::with_capacity(4);
-
-    let (sampler, backend) = build_audio_sampler(true);
-
-    let _ = backend.load_file("./samples/amen.wav");
-
-    let sink = audio_graph.add_audio_unit(AddNodeProps::Sampler { node: sampler });
-
-    let comb_filter = audio_graph.add_audio_unit(AddNodeProps::CombFilter { delay_len: 120, feedback: 0.8 });
-
-    audio_graph.add_edge(sink, comb_filter);
-
-    audio_graph.set_sink_index(comb_filter);
-
-    // Build CPAL output stream
-    let stream = device.build_output_stream(
-        config,
-        move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
-            assert_no_alloc(|| write_data::<FRAME_SIZE, CHANNEL_COUNT, f32>(data, &mut audio_graph))
-        },
-        |err| eprintln!("An output stream error occurred: {}", err),
-        None,
-    )?;
-
-    stream.play().unwrap();
-
-
-    std::thread::park(); // Keep alive
-
-    Ok(())
-}
-
-
-fn main() {
-    let host = cpal::host_from_id(cpal::HostId::Jack).expect("JACK host not available");
-    let device = host.default_output_device().expect("No output device available");
-
-    let config = StreamConfig {
-        channels: CHANNEL_COUNT as u16,
-        sample_rate: SampleRate(SAMPLE_RATE),
-        buffer_size: BufferSize::Fixed(FRAME_SIZE as u32),
-    };
-
-    run::<f32>(&device, &config.into()).unwrap();
-}
\ No newline at end of file
diff --git a/examples/multi_tap.rs b/examples/multi_tap.rs
deleted file mode 100644
index da7720a..0000000
--- a/examples/multi_tap.rs
+++ /dev/null
@@ -1,155 +0,0 @@
-use std::time::Duration;
-
-use mini_graph::mini_graph::audio_graph::{DynamicAudioGraph, AudioGraphApi, AddNodeProps};
-use mini_graph::mini_graph::bang::Bang;
-use mini_graph::mini_graph::write::write_data;
-use mini_graph::nodes::audio::{osc::Wave};
-use assert_no_alloc::*;
-use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
-use cpal::{BufferSize, BuildStreamError, FromSample, SampleRate, SizedSample, StreamConfig};
-
-
-#[cfg(debug_assertions)] // required when disable_release is set (default)
-#[global_allocator]
-static A: AllocDisabler = AllocDisabler;
-
-const SAMPLE_RATE: u32 = 48_000;
-const FRAME_SIZE: usize = 1024;
-const CHANNEL_COUNT: usize = 2;
-
-
-fn run<const N: usize, T>(device: &cpal::Device, config: &cpal::StreamConfig) -> Result<(), BuildStreamError>
-where
-    T: SizedSample + FromSample<f64>,
-{
-    let mut audio_graph = DynamicAudioGraph::<FRAME_SIZE, CHANNEL_COUNT>::with_capacity(32);
-
-    let clock_one = audio_graph.add_audio_unit(AddNodeProps::Clock {
-        sample_rate: SAMPLE_RATE,
-        rate: Duration::from_secs_f32(0.5),
-    });
-
-    let clock_two = audio_graph.add_audio_unit(AddNodeProps::Clock {
-        sample_rate: SAMPLE_RATE,
-        rate: Duration::from_secs_f32(2.0 / 3.0),
-    });
-
-    let iterator_one = audio_graph.add_audio_unit(AddNodeProps::Iter {
-        values: &[Bang::BangF32(440.0 / 2.0), Bang::BangF32(523.251 / 2.0), Bang::BangF32(783.991 / 2.0)],
-    });
-
-    let iterator_two = audio_graph.add_audio_unit(AddNodeProps::Iter {
-        values: &[Bang::BangF32(440.0 * 2.0), Bang::BangF32(523.251 * 2.0), Bang::BangF32(783.991 * 2.0)],
-    });
-
-    let adsr_one = audio_graph.add_audio_unit(AddNodeProps::ADSR {
-        sample_rate: SAMPLE_RATE,
-    });
-
-    let adsr_two = audio_graph.add_audio_unit(AddNodeProps::ADSR {
-        sample_rate: SAMPLE_RATE,
-    });
-
-    let osc_one = audio_graph.add_audio_unit(AddNodeProps::Oscillator {
-        freq: 440.0,
-        sample_rate: SAMPLE_RATE,
-        phase: 0.0,
-        wave: Wave::SawWave,
-    });
-
-    let osc_two = audio_graph.add_audio_unit(AddNodeProps::Oscillator {
-        freq: 440.0,
-        sample_rate: SAMPLE_RATE,
-        phase: 0.0,
-        wave: Wave::SawWave,
-    });
-
-    audio_graph.add_edges(&[
-        (clock_one, iterator_one),
-        (iterator_one, osc_one),
-        (osc_one, adsr_one),
-        (clock_one, adsr_one),
-
-        (clock_two, iterator_two),
-        (iterator_two, osc_two),
-        (osc_two, adsr_two),
-        (clock_two, adsr_two),
-    ]);
-
-    let mixer = audio_graph.add_audio_unit(AddNodeProps::Mixer);
-
-    audio_graph.add_edges(&[(adsr_one, mixer), (adsr_two, mixer)]);
-
-    let delay_name = "delay_bus";
-    let delay_capacity = (SAMPLE_RATE * 2) as usize;
-
-    let write_one = audio_graph.add_audio_unit(AddNodeProps::DelayWrite {
-        delay_line_name: delay_name,
-        capacity: delay_capacity,
-        name: delay_name,
-    });
-
-    let tap_one = audio_graph.add_audio_unit(AddNodeProps::DelayTap {
-        name: delay_name,
-        sample_offset: (2.0 / 3.0) * SAMPLE_RATE as f32,
-        gain: 0.8,
-    });
-
-    let tap_two = audio_graph.add_audio_unit(AddNodeProps::DelayTap {
-        name: delay_name,
-        sample_offset: 1.0 * SAMPLE_RATE as f32,
-        gain: 0.6,
-    });
-
-    let tap_three = audio_graph.add_audio_unit(AddNodeProps::DelayTap {
-        name: delay_name,
-        sample_offset: (3.0 / 2.0) * SAMPLE_RATE as f32,
-        gain: 0.4,
-    });
-
-    let mixer_two = audio_graph.add_audio_unit(AddNodeProps::Mixer);
-
-    audio_graph.add_edges(&[
-        (mixer, mixer_two),        
-        (mixer, write_one),        
-        (tap_one, mixer_two),      
-        (tap_two, mixer_two),
-        (tap_three, mixer_two),
-    ]);
-
-    audio_graph.set_sink_index(mixer_two);
-
-    let stream = device.build_output_stream(
-        config,
-        move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
-            write_data::<FRAME_SIZE, CHANNEL_COUNT, f32>(data, &mut audio_graph)
-        },
-        |err| eprintln!("An output stream error occurred: {}", err),
-        None,
-    )?;
-
-    stream.play().unwrap();
-
-    std::thread::park();
-
-    Ok(())
-}
-
-
-fn main(){
-    
-    let host = cpal::host_from_id(cpal::HostId::Jack)
-    .expect("JACK host not available");
-
-    let device = host.default_output_device().unwrap();
-
-    let config = StreamConfig {
-        channels: CHANNEL_COUNT as u16,
-        sample_rate: SampleRate(SAMPLE_RATE),
-        buffer_size: BufferSize::Fixed(FRAME_SIZE as u32),
-    };
-
-    run::<FRAME_SIZE, f32>(&device, &config.into()).unwrap();
-
-    std::thread::park();
-}
\ No newline at end of file
diff --git a/mini-graph-macros/Cargo.toml b/mini-graph-macros/Cargo.toml
new file mode 100644
index 0000000..bd49e3f
--- /dev/null
+++ b/mini-graph-macros/Cargo.toml
@@ -0,0 +1,12 @@
+[package]
+name = "mini-graph-macros"
+version = "0.1.0"
+edition = "2021"
+
+[lib]
+proc-macro = true
+
+[dependencies]
+quote = "1"
+proc-macro2 = "1.0"
+syn = "2.0"
\ No newline at end of file
diff --git a/mini-graph-macros/src/lib.rs b/mini-graph-macros/src/lib.rs
new file mode 100644
index 0000000..db0297c
--- /dev/null
+++ b/mini-graph-macros/src/lib.rs
@@ -0,0 +1,65 @@
+use proc_macro::TokenStream;
+use quote::quote;
+use syn::parse_macro_input;
+
+#[proc_macro_derive(Port)]
+pub fn derive_audio_port(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
+    let input = parse_macro_input!(input as syn::DeriveInput);
+
+    let ident = input.ident;
+
+    let generics = input.generics.clone();
+    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
+
+    let mut to_index_blocks = vec![];
+    let mut from_index_blocks = vec![];
+
+    let data_enum = match input.data {
+        syn::Data::Enum(data) => data,
+        _ => {
+            return quote! {
+                compile_error!("`#[derive(Port)]` can only be used on enums");
+            }
+            .into();
+        }
+    };
+
+    for v in &data_enum.variants {
+        match &v.fields {
+            syn::Fields::Unit => {}
+            _ => {
+                let span = v.ident.span();
+                return syn::Error::new(span, "`#[derive(Port)]` requires unit variants")
+                    .to_compile_error()
+                    .into();
+            }
+        }
+    }
+
+    for (i, variant) in data_enum.variants.iter().enumerate() {
+        let v = &variant.ident;
+
+        from_index_blocks.push(quote! { Self::#v => #i, });
+        to_index_blocks.push(quote! {#i => Ok(Self::#v),});
+    }
+
+    let expanded = quote! {
+        impl #impl_generics Port for #ident #ty_generics #where_clause {            
+            #[inline(always)]
+            fn into_index(&self) -> usize {
+                match self {
+                    #(#from_index_blocks)*
+                }
+            }
+            #[inline(always)]
+            fn from_index(index: usize) -> Result<Self, PortError> {
+                match index {
+                    #(#to_index_blocks)*
+                    _ => Err(PortError::InvalidPort),
+                }
+            }
+        }
+    };
+
+    TokenStream::from(expanded)
+}
\ No newline at end of file
diff --git a/mini-graph/Cargo.toml b/mini-graph/Cargo.toml
new file mode 100644
index 0000000..0e31007
--- /dev/null
+++ b/mini-graph/Cargo.toml
@@ -0,0 +1,17 @@
+[package]
+name = "mini-graph"
+version = "0.1.0"
+edition = "2021"
+
+[features]
+default = ["std"]
+std     = []
+
+[dependencies]
+assert_no_alloc = "1.1.2"
+hashbrown = { version = "0.15.4", features = ["inline-more"] }
+indexmap = "2.10.0"
+heapless = "0.8.0"
+portable-atomic = { version = "1.11.1", features = ["float"] }
+arc-swap = "1.7.1"
+mini-graph-macros = { path = "../mini-graph-macros" }
\ No newline at end of file
diff --git a/src/mini_graph/buffer.rs b/mini-graph/src/lib.rs
similarity index 52%
rename from src/mini_graph/buffer.rs
rename to mini-graph/src/lib.rs
index a543c1f..39c8554 100644
--- a/src/mini_graph/buffer.rs
+++ b/mini-graph/src/lib.rs
@@ -1,6 +1,14 @@
+// pub mod mini_graph;
+// pub mod nodes;
+// pub mod utils;
+
+mod nodes;
+
 use core::fmt;
 use core::ops::{Deref, DerefMut};
 
+use mini_graph_macros::Port;
+
 pub type Frame<const BUFFER_SIZE: usize, const CHANNEL_COUNT: usize> = [Buffer<BUFFER_SIZE>; CHANNEL_COUNT];
 #[derive(Clone, Copy)]
 pub struct Buffer<const BUFFER_SIZE: usize> {
@@ -46,4 +54,50 @@ impl<const N: usize> DerefMut for Buffer<N> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.data[..]
     }
-}
\ No newline at end of file
+}
+
+#[derive(Debug, PartialEq)]
+pub enum PortError {
+    InvalidPort
+}
+
+struct AudioContext {
+    sample_rate: f32,
+    frame_size: usize,
+    channels: usize
+}
+
+pub trait Port {
+    fn into_index(&self) -> usize;
+    fn from_index(index: usize) -> Result<Self, PortError> where Self: Sized;
+}
+
+trait Node<const N: usize, const C: usize> {
+    type Inputs: Port;
+
+    fn process(&mut self, ctx: &AudioContext, inputs: &[Frame<N, C>], output: &mut Frame<N, C>){}
+}
+
+#[derive(Port, PartialEq, Debug)]
+enum OscillatorInputs {
+    Freq,
+    FM,
+}
+
+struct Oscillator {
+    phase: f32,
+}
+impl<const N: usize, const C: usize> Node<N, C> for Oscillator {
+    type Inputs = OscillatorInputs;
+
+    fn process(&mut self, ctx: &AudioContext, inputs: &[Frame<N, C>], output: &mut Frame<N, C>) {
+        let freq = inputs.get(OscillatorInputs::Freq.into_index());
+        let fm = inputs.get(OscillatorInputs::FM.into_index());
+
+
+    }
+}
+
+
+
+
diff --git a/mini-graph/tests/macros.rs b/mini-graph/tests/macros.rs
new file mode 100644
index 0000000..3a62db1
--- /dev/null
+++ b/mini-graph/tests/macros.rs
@@ -0,0 +1,18 @@
+use mini_graph::{Port, PortError};
+use mini_graph_macros::Port;
+
+#[test]
+fn macro_port_test_basic() {
+    #[derive(Port, PartialEq, Debug)]
+    enum OscillatorInputs {
+        Freq,
+        FM,
+    }
+
+    assert_eq!(OscillatorInputs::Freq.into_index(), 0);
+    assert_eq!(OscillatorInputs::FM.into_index(), 1);
+
+    assert_eq!(OscillatorInputs::from_index(0), Ok(OscillatorInputs::Freq));
+    assert_eq!(OscillatorInputs::from_index(1), Ok(OscillatorInputs::FM));
+    assert_eq!(OscillatorInputs::from_index(2), Err(PortError::InvalidPort));
+}
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
deleted file mode 100644
index 986bdcc..0000000
--- a/src/lib.rs
+++ /dev/null
@@ -1,3 +0,0 @@
-pub mod mini_graph;
-pub mod nodes;
-pub mod utils;
\ No newline at end of file
diff --git a/src/mini_graph/audio_graph.rs b/src/mini_graph/audio_graph.rs
deleted file mode 100644
index 4abddc6..0000000
--- a/src/mini_graph/audio_graph.rs
+++ /dev/null
@@ -1,311 +0,0 @@
-use std::time::Duration;
-
-use hashbrown::HashMap;
-use indexmap::IndexSet;
-
-use crate::mini_graph::bang::Bang;
-use crate::mini_graph::node::{AudioNode, AudioUnit};
-use crate::nodes::audio::adsr::ADSR;
-use crate::nodes::audio::comb_filter::CombFilter;
-use crate::nodes::audio::delay::{DelayLine, DelayTap, DelayWrite};
-use crate::nodes::audio::filters::{FilterType, Svf};
-use crate::nodes::audio::gain::Gain;
-use crate::nodes::audio::hard_clipper::HardClipper;
-use crate::nodes::audio::mixer::Mixer;
-use crate::nodes::audio::osc::{Oscillator, Wave};
-use crate::nodes::audio::sampler::Sampler;
-use crate::nodes::control::clock::Clock;
-use crate::nodes::control::iter::BangIter;
-use crate::nodes::control::lfo::Lfo;
-use crate::nodes::control::log::Log;
-use crate::nodes::control::signal::{build_signal, Param};
-
-pub trait AudioGraph<const BUFFER_SIZE: usize, const CHANNEL_COUNT: usize> {
-    fn next_block(&mut self) -> &Frame<BUFFER_SIZE, CHANNEL_COUNT>;
-    fn invalidate_sort_order(&mut self);
-}
-
-use super::buffer::{Buffer, Frame};
-use super::graph::{DynamicGraph, Graph};
-
-const MAXIMUM_BANG_INPUT_PORTS: usize = 4;
-
-pub struct AudioContext<const BUFFER_SIZE: usize, const CHANNEL_COUNT: usize> {
-    // Audio Work Buffers
-    audio_inputs_buffer: Vec<Frame<BUFFER_SIZE, CHANNEL_COUNT>>, // A preallocated vector that contains a node's inputs. This is cleared and found for each node
-    audio_output_buffers: Vec<Frame<BUFFER_SIZE, CHANNEL_COUNT>>, // A preallocated vector that nodes write to
-    // Bang Work Buffers
-    bang_inputs_buffer: Vec<Bang>, // A preallocated vector that contains a node's inputs
-    bang_output_buffers: Vec<Bang>,
-    // Delay Lines
-    delay_lines: Vec<DelayLine<BUFFER_SIZE, CHANNEL_COUNT>>,
-    delay_name_to_index_map: HashMap<&'static str, usize>
-}
-impl<const N: usize, const C: usize> AudioContext<N, C>{
-    pub fn with_capacity(capacity: usize) -> Self {
-        Self {
-            audio_inputs_buffer: Vec::with_capacity(capacity),
-            audio_output_buffers: vec![[Buffer::<N>::default(); C]; capacity],
-            bang_inputs_buffer: vec![Bang::Empty; MAXIMUM_BANG_INPUT_PORTS],
-            bang_output_buffers: vec![Bang::Empty; capacity],
-            delay_lines: Vec::new(), // None of this is allocated yet
-            delay_name_to_index_map: HashMap::new()
-        }
-    }
-    #[inline(always)]
-    fn execute_audio_unit(&mut self, audio_unit: &mut AudioUnit<N, C>, node_index: &usize, dependencies: &IndexSet<usize>, override_inputs: Option<&[Frame<N,C>]>){
-        self.handle_bang_audio_unit(audio_unit, node_index, dependencies);
-        self.process_audio_unit(audio_unit, node_index, dependencies, override_inputs);
-    }
-    #[inline(always)]
-    fn handle_bang_audio_unit(&mut self, audio_unit: &mut AudioUnit<N, C>, node_index: &usize, dependencies: &IndexSet<usize>){
-        self.bang_inputs_buffer.iter_mut().for_each(|x| {
-            *x = Bang::Empty
-        });
-
-        for (i, &src) in dependencies.iter().enumerate() {
-            self.bang_inputs_buffer[i] = self.bang_output_buffers[src];
-        }
-
-        match audio_unit {
-            AudioUnit::AudioNode { node } => node.handle_bang(&self.bang_inputs_buffer.as_slice(), &mut self.bang_output_buffers[*node_index]),
-            AudioUnit::DelayTapNode { node } => node.handle_bang(&self.bang_inputs_buffer.as_slice(), &mut self.bang_output_buffers[*node_index]),
-            AudioUnit::DelayWriteNode { node } => node.handle_bang(&self.bang_inputs_buffer.as_slice(), &mut self.bang_output_buffers[*node_index]),
-            AudioUnit::IONode { node } => node.handle_bang(&self.bang_inputs_buffer.as_slice(), &mut self.bang_output_buffers[*node_index]),
-        }
-    }
-    #[inline(always)]
-    fn process_audio_unit(&mut self, audio_unit: &mut AudioUnit<N, C>, node_index: &usize, dependencies: &IndexSet<usize>, override_inputs: Option<&[Frame<N,C>]>){
-        match audio_unit {
-            AudioUnit::AudioNode { node } => {
-                self.audio_inputs_buffer.clear();
-                self.audio_inputs_buffer.reserve(dependencies.len());
-
-                for &src in dependencies {
-                    self.audio_inputs_buffer.push(self.audio_output_buffers[src]);
-                }
-
-                let output = &mut self.audio_output_buffers[*node_index];
-
-                if let Some(inputs) = override_inputs {
-                    node.process(inputs, output);
-                }
-                else {
-                    node.process(&self.audio_inputs_buffer, output);
-                }
-            },
-            AudioUnit::DelayWriteNode { node } => {
-                self.audio_inputs_buffer.clear();
-                self.audio_inputs_buffer.reserve(dependencies.len());
-
-                for &src in dependencies {
-                    self.audio_inputs_buffer.push(self.audio_output_buffers[src]);
-                }
-
-                let delay_index = node.get_delay_line_index();
-
-                let delay_line = self.delay_lines.get_mut(*delay_index).expect("Delay line out of bounds!");
-        
-                if let Some(inputs) = override_inputs {
-                    node.process(inputs, delay_line);
-                }
-                else {
-                    node.process(&self.audio_inputs_buffer, delay_line);
-                }
-            },
-            AudioUnit::DelayTapNode { node } => {
-                let delay_index = node.get_delay_line_index();
-                if let Some(delay_buffer) = self.delay_lines.get_mut(*delay_index) {
-                    let output = &mut self.audio_output_buffers[*node_index];
-
-                    node.process(delay_buffer, output);
-                }
-            },
-            AudioUnit::IONode { node } => {
-                let output = &mut self.audio_output_buffers[*node_index];
-                node.process(output);
-            }
-        }
-    }
-    #[inline(always)]
-    fn get_buffer_at_index(&self, index: usize) -> &Frame<N, C> {
-        &self.audio_output_buffers[index]
-    }
-    fn add_delay_line(&mut self, name: &'static str, capacity: usize) -> usize {
-        let new_delay_line = DelayLine::new(capacity);
-        let index = self.delay_lines.len();
-        self.delay_lines.push(new_delay_line);
-        self.delay_name_to_index_map.insert(name, index);
-        index
-    }
-    fn get_delay_line_index(&self, name: &'static str) -> Option<usize> {
-        self.delay_name_to_index_map.get(name).copied()
-    }
-}
-
-/// A resizable audio graph for experimentation. Pre-allocated, but not realtime safe, as the underlying vectors can grow.
-/// We will soon add a fixed size, no_std graph for better real-time performance, or more suitable for
-///  sub-graph development.
-pub struct DynamicAudioGraph<const N: usize, const C: usize> {
-    graph: DynamicGraph<AudioUnit<N, C>>,
-    audio_context: AudioContext<N, C>,
-    // Cached sort order that is invalidated when adding a new edge
-    sort_order: Vec<usize>,
-    // Index that our node delivers the final sample from
-    sink_index: usize,
-}
-
-impl<const N: usize, const C: usize> DynamicAudioGraph<N, C> {
-    pub fn with_capacity(capacity: usize) -> Self {
-        let graph = DynamicGraph::with_capacity(capacity);
-        Self {
-            graph,
-            audio_context: AudioContext::with_capacity(capacity),
-            sort_order: Vec::with_capacity(capacity),
-            sink_index: 0,
-        }
-    }
-
-    pub fn add_edge(&mut self, from: usize, to: usize) {
-        self.graph.add_edge(from, to);
-        self.invalidate_sort_order();
-    }
-
-    pub fn add_edges(&mut self, edges: &[(usize, usize)]) {
-        self.graph.add_edges(edges);
-        self.invalidate_sort_order();
-    }
-
-    pub fn set_sink_index(&mut self, sink: usize) {
-        self.sink_index = sink;
-    }
-
-    fn invalidate_sort_order(&mut self) {
-        match self.graph.topo_sort() {
-            Ok(order) => self.sort_order = order,
-            Err(_) => panic!("Cycle detected in audio graph"),
-        }
-    }
-
-    #[inline(always)]
-    pub fn next_block(&mut self, inputs: Option<&[Frame<N,C>]>) -> &Frame<N, C> {
-        for (i, &node_index) in self.sort_order.iter().enumerate() {
-            let audio_unit = &mut self.graph.nodes[node_index];
-            
-            let incoming_nodes = &self.graph.incoming[node_index];
-
-            let override_inputs = if i == 0 { inputs } else { None };
-            self.audio_context.execute_audio_unit(audio_unit, &node_index, incoming_nodes, override_inputs);
-        }
-
-        self.audio_context.get_buffer_at_index(self.sink_index)
-    }
-}
-
-impl<const BUFFER_SIZE: usize, const CHANNEL_COUNT: usize> AudioNode<BUFFER_SIZE, CHANNEL_COUNT> for DynamicAudioGraph<BUFFER_SIZE, CHANNEL_COUNT> {
-    fn process(&mut self, inputs: &[Frame<BUFFER_SIZE, CHANNEL_COUNT>], output: &mut Frame<BUFFER_SIZE, CHANNEL_COUNT>) {
-        let next_block = self.next_block(Some(inputs));
-        for (output, input) in output.iter_mut().zip(next_block) {
-            *output = *input;
-        }
-    }
-}
-
-pub enum AddNodeProps<const N: usize, const C: usize> {
-    // AudioNodes
-    ADSR { sample_rate: u32} ,
-    DelayWrite { delay_line_name: &'static str, capacity: usize, name: &'static str } ,
-    DelayTap { gain: f32, sample_offset: f32, name: &'static str} ,
-    Filter { sample_rate: f32, filter_type: FilterType, cutoff: f32, gain: f32, q: f32 },
-    Gain { gain: f32 },
-    HardClipper { limit: f32 },
-    Mixer,
-    Oscillator { freq: f32, sample_rate: u32, phase: f32, wave: Wave },
-    CombFilter { delay_len: usize, feedback: f32 },
-    // BangNodes
-    Clock { sample_rate: u32, rate: Duration },
-    Iter { values: &'static [Bang]},
-    Lfo { freq: f32, offset: f32, amp: f32, phase: f32, sample_rate: f32 },
-    Log,
-    MidiToF,
-    Graph { graph: DynamicAudioGraph<N, C> },
-    Sampler { node: Sampler<N, C>}
-}
-
-
-pub trait AudioGraphApi<const N: usize, const C: usize> {
-    fn add_audio_unit(&mut self, props: AddNodeProps<N, C>) -> usize;
-    fn add_control_unit(&mut self, min: f32, max: f32, initial: f32) -> (usize, Param);
-}
-
-impl<const N: usize, const C: usize> AudioGraphApi<N, C> for DynamicAudioGraph<N, C> {
-    // This probably won't scale well, perhaps a macro in the future?
-    fn add_audio_unit(&mut self, props: AddNodeProps<N, C>) -> usize {
-        let node: AudioUnit<N, C> = match props {
-            AddNodeProps::ADSR { sample_rate } => AudioUnit::AudioNode {
-                node: Box::new(ADSR::new(sample_rate)),
-            },
-            AddNodeProps::Filter { sample_rate, filter_type, cutoff, gain, q } => AudioUnit::AudioNode {
-                node: Box::new(Svf::new(sample_rate, filter_type, cutoff, gain, q)),
-            },
-            AddNodeProps::Gain { gain } => AudioUnit::AudioNode {
-                node: Box::new(Gain::new(gain)),
-            },
-            AddNodeProps::HardClipper { limit } => AudioUnit::AudioNode {
-                node: Box::new(HardClipper::new(limit)),
-            },
-            AddNodeProps::Mixer => AudioUnit::AudioNode {
-                node: Box::new(Mixer {}),
-            },
-            AddNodeProps::Oscillator { freq, sample_rate, phase, wave } => AudioUnit::AudioNode {
-                node: Box::new(Oscillator::new(freq, sample_rate, phase, wave)),
-            },
-            AddNodeProps::CombFilter { delay_len, feedback } => AudioUnit::AudioNode {
-                node: Box::new(CombFilter::new(delay_len, feedback)),
-            },
-            // Bang Nodes
-            AddNodeProps::Clock { sample_rate, rate } => AudioUnit::AudioNode {
-                node: Box::new(Clock::new(sample_rate, rate)),
-            },
-            AddNodeProps::Iter { values } => AudioUnit::AudioNode {
-                node: Box::new(BangIter::new(values)),
-            },
-            AddNodeProps::Lfo { freq, offset, amp, phase, sample_rate } => AudioUnit::AudioNode {
-                node: Box::new(Lfo::new(freq, offset, amp, phase, sample_rate)),
-            },
-            AddNodeProps::Log => AudioUnit::AudioNode {
-                node: Box::new(Log {}),
-            },
-            AddNodeProps::MidiToF => AudioUnit::AudioNode {
-                node: Box::new(Log {}),
-            },
-            // Delay Nodes
-            AddNodeProps::DelayWrite { delay_line_name, capacity, name } => {
-                let index = self.audio_context.add_delay_line(delay_line_name, capacity);
-                let new_node = DelayWrite::new(name, index);
-                
-                AudioUnit::DelayWriteNode { node: Box::new(new_node) }
-            },
-            AddNodeProps::DelayTap { name, gain, sample_offset } => {
-                let index = self.audio_context.get_delay_line_index(name).expect("Delay line not found!");
-                let new_node = DelayTap::new(sample_offset, index, gain);
-                
-                AudioUnit::DelayTapNode { node: Box::new(new_node) }
-            },
-            AddNodeProps::Graph { graph } => AudioUnit::AudioNode {
-                node: Box::new(graph),
-            },
-            AddNodeProps::Sampler { node } => AudioUnit::IONode { node: Box::new(node) }
-        };
-        let index = self.graph.add_node(node);
-        self.invalidate_sort_order();
-        index
-    }
-    // Slightly different signature here, although the Signal is technically a node.
-    fn add_control_unit(&mut self, min: f32, max: f32, initial: f32) -> (usize, Param) {
-        let (node, param ) = build_signal(min, max, initial);
-        let index = self.graph.add_node(AudioUnit::AudioNode { node: Box::new(node) });
-        self.invalidate_sort_order();
-        (index, param)
-    }
-}
\ No newline at end of file
diff --git a/src/mini_graph/bang.rs b/src/mini_graph/bang.rs
deleted file mode 100644
index 190463d..0000000
--- a/src/mini_graph/bang.rs
+++ /dev/null
@@ -1,26 +0,0 @@
-#[derive(Clone, Copy, Debug, PartialEq)]
-pub enum Bang {
-    Bang,
-    BangF32(f32),
-    BangMidi(MidiData), // Perhaps an enum in the future
-    BangU32(u32),
-    BangBool(bool),
-    BangUSize(usize),
-    SetParamU32(usize, u32),
-    SetParamF32(usize, f32),
-    SetParamBool(usize, bool),
-    Empty,
-}
-
-#[derive(Clone, Copy, Debug, PartialEq)]
-pub struct MidiData {
-    pub key: u8,
-    pub vel: u8
-}
-
-#[derive(Clone, Copy, Debug, PartialEq)]
-pub enum Midi {
-    NoteOn(MidiData),
-    NoteOff(MidiData),
-    // TODO: Aftertouch, etc.
-}
\ No newline at end of file
diff --git a/src/mini_graph/graph.rs b/src/mini_graph/graph.rs
deleted file mode 100644
index 0ffa853..0000000
--- a/src/mini_graph/graph.rs
+++ /dev/null
@@ -1,121 +0,0 @@
-
-// #![no_std]
-// extern crate alloc;
-
-use std::collections::VecDeque;
-
-use indexmap::IndexSet;
-
-
-pub enum GraphError {
-    MaximumCapacity,
-    CycleDetected
-}
-
-/// Our graph trait that will let us more easily reuse
-/// some functionality across graphs. The topo_sort and
-/// invalidate sort order are required, as all of our 
-/// eventual audio graphs will use this functionality. 
-pub trait Graph<N> {
-    type Node;
-    type Nid;
-    type Connections;
-
-     fn with_capacity(capacity: usize) -> Self;
-     fn add_node(&mut self, node:N) -> Self::Nid;
-     fn add_edge(&mut self, from: Self::Nid, to: Self::Nid);
-     fn add_edges(&mut self, edges: &[(Self::Nid, Self::Nid)]);
-     fn topo_sort(&self) -> Result<Vec<usize>, GraphError>;
-     fn get_node_mut(&mut self, index: usize) -> &mut N;
-     fn get_incoming(&self, index: usize) -> &Self::Connections;
-}
-
-/// A resizble graph for std environments, preferable for applications
-/// with changing graph sizes. These will cause heap allocations which
-/// can cause artifacts or missed frames in the audio thread, so it is 
-/// better to preallocate when possible.
-#[cfg(feature = "std")]
-pub struct DynamicGraph<N> {
-    pub nodes: Vec<N>,
-    pub incoming: Vec<IndexSet<usize>>,
-    pub outgoing: Vec<IndexSet<usize>>,
-}
-impl<N> Graph<N> for DynamicGraph<N> {
-    type Nid = usize;
-    type Node = N;
-    type Connections = IndexSet<Self::Nid>;
-
-    fn with_capacity(capacity: usize) -> Self {
-        Self {
-            nodes: Vec::with_capacity(capacity),
-            incoming: vec![IndexSet::with_capacity(capacity); capacity],
-            outgoing: vec![IndexSet::with_capacity(capacity); capacity],
-        }
-    }
-    #[inline(always)]
-    fn get_node_mut(&mut self, index: usize) -> &mut N {
-        &mut self.nodes[index]
-    }
-
-    #[inline(always)]
-    fn get_incoming(&self, index: usize) -> &IndexSet<usize> {
-        &self.incoming[index]
-    }
-
-    fn add_node(&mut self, node:N) -> Self::Nid {
-        let id = self.nodes.len();
-        self.nodes.push(node);
-        id
-    }
-    fn add_edge(&mut self, from: usize, to: usize) {
-        if from == to { return };
-        self.outgoing[from].insert(to);
-        self.incoming[to].insert(from);
-    }
-    fn add_edges(&mut self, edges: &[(usize, usize)]) {
-        for (from, to) in edges {
-            if from == to {
-                continue
-            }
-            self.outgoing[*from].insert(*to);
-            self.incoming[*to].insert(*from);
-        }
-    }
-    /// TODO: can we use some scratch buffers to remove a runtime heap alloc?
-    fn topo_sort(&self) -> Result<Vec<usize>, GraphError> {
-        let mut indegree = vec![0; self.nodes.len()];
-
-        for targets in &self.outgoing {
-            for target in targets {
-                indegree[*target] += 1;
-            }
-        }
-
-        let mut no_incoming_edges_queue = VecDeque::new();
-        for (index, count) in indegree.iter().enumerate() {
-            if *count == 0 {
-                no_incoming_edges_queue.push_back(index);
-            }
-        }
-
-        let mut sorted: Vec<usize> = Vec::with_capacity(self.nodes.len());
-        while let Some(node_index) = no_incoming_edges_queue.pop_front() {
-            sorted.push(node_index);
-            if let Some(connections) = self.outgoing.get(node_index){
-                for v_id in connections {
-                    indegree[*v_id] -= 1;
-                    if indegree[*v_id] == 0 {
-                        no_incoming_edges_queue.push_back(*v_id);
-                    }
-                }
-            }
-        }
-
-        if sorted.len() == indegree.len() {
-            Ok(sorted)
-        }
-        else {
-            Err(GraphError::CycleDetected)
-        }
-    }
-}
diff --git a/src/mini_graph/mod.rs b/src/mini_graph/mod.rs
deleted file mode 100644
index ad87378..0000000
--- a/src/mini_graph/mod.rs
+++ /dev/null
@@ -1,6 +0,0 @@
-pub mod audio_graph;
-pub mod buffer;
-pub mod graph;
-pub mod node;
-pub mod write;
-pub mod bang;
diff --git a/src/mini_graph/node.rs b/src/mini_graph/node.rs
deleted file mode 100644
index afca01f..0000000
--- a/src/mini_graph/node.rs
+++ /dev/null
@@ -1,57 +0,0 @@
-use heapless::spsc::{Consumer};
-
-use crate::mini_graph::buffer::Frame;
-use crate::mini_graph::bang::Bang;
-use crate::nodes::audio::delay::DelayLine;
-
-
-/// These different AudioUnits all have different strategies for fetching audio.
-/// 
-/// AudioNodes are chained in a DAG, and use their dependencies to calculate audio
-/// 
-/// DelayTap/Write nodes read/write to specific delay buffers, ignoring their input/outputs respectively
-/// 
-/// IONodes take a channel, maybe generic in the future
-pub enum AudioUnit<const N: usize, const C: usize> {
-    AudioNode { node: BoxedAudioNode<N, C> },
-    DelayTapNode { node: BoxedDelayTapNode<N, C>},
-    DelayWriteNode { node: BoxedDelayWriteNode<N, C>},
-    IONode { node: BoxedIONode<N, C> }
-}
-
-pub trait AudioNode<const N: usize, const C: usize> {
-    fn process(&mut self, inputs: &[Frame<N, C>], output: &mut Frame<N, C>){}
-    fn handle_bang(&mut self, inputs: &[Bang], output: &mut Bang) {}
-}
-
-pub type BoxedAudioNode<const N: usize, const C: usize> = Box<dyn AudioNode<N, C> + Send> ;
-
-pub trait DelayTapNode<const N: usize, const C: usize> {
-    // Functions for registering the delay line with the AudioContext
-    fn get_delay_line_index(&self) -> &usize;
-
-    fn process(&mut self, delay_line: &DelayLine<N, C>, output: &mut Frame<N, C> ){}
-    fn handle_bang(&mut self, inputs: &[Bang], output: &mut Bang) { }
-}
-
-pub type BoxedDelayTapNode<const N: usize, const C: usize> = Box<dyn DelayTapNode<N, C> + Send> ;
-
-pub trait DelayWriteNode<const N: usize, const C: usize> {
-    // Functions for registering the delay line with the AudioContext
-    fn get_delay_line_index(&self) -> &usize;
-
-    fn process(&mut self, inputs: &[Frame<N, C>], delay_line: &mut DelayLine<N, C>){}
-    fn handle_bang(&mut self, inputs: &[Bang], output: &mut Bang) {}
-}
-
-pub type BoxedDelayWriteNode<const N: usize, const C: usize> = Box<dyn DelayWriteNode<N, C> + Send> ;
-
-const MAXIMUM_QUEUE_SIZE: usize = 16;
-
-pub trait IONode<const N: usize, const C: usize> {
-    fn process(&mut self, output: &mut Frame<N, C>){}
-    fn handle_bang(&mut self, inputs: &[Bang], output: &mut Bang) {}
-    fn set_receiver(&mut self, receiver: Consumer<Frame<N, C>, MAXIMUM_QUEUE_SIZE>) {} // Take ownership of some receiver
-}
-
-pub type BoxedIONode<const N: usize, const C: usize> = Box<dyn IONode<N, C> + Send>;
\ No newline at end of file
diff --git a/src/mini_graph/write.rs b/src/mini_graph/write.rs
deleted file mode 100644
index 9818e0b..0000000
--- a/src/mini_graph/write.rs
+++ /dev/null
@@ -1,27 +0,0 @@
-use cpal::{FromSample, SizedSample};
-
-use crate::mini_graph::audio_graph::DynamicAudioGraph;
-
-// / The function that takes an input from the audio pipeline, 
-// / and delivers it to the CPAL slice. The CPAL slice is a 
-// / frame of a certain buffer size. If you request a buffer size of 256,
-// / with 2 channels, the output will have a length of 512. This function
-// / also takes ownership of the audio pipeline.
-#[inline(always)]
-pub fn write_data<const BUFFER_SIZE: usize, const CHANNEL_COUNT: usize, T>(
-    output: &mut [T],
-    audio_graph: &mut DynamicAudioGraph<BUFFER_SIZE, CHANNEL_COUNT>
-)
-where
-    T: SizedSample + FromSample<f64>,
-{    
-    
-    let next_pipeline_buffer = audio_graph.next_block(None);
-
-    for (frame_index, frame) in output.chunks_mut(CHANNEL_COUNT).enumerate() {
-        for (channel, sample) in frame.iter_mut().enumerate() {
-            let pipeline_next_frame = &next_pipeline_buffer[channel];
-            *sample = T::from_sample(pipeline_next_frame[frame_index] as f64);
-        }
-    }
-}
diff --git a/src/nodes/audio/adsr.rs b/src/nodes/audio/adsr.rs
deleted file mode 100644
index 8a6f957..0000000
--- a/src/nodes/audio/adsr.rs
+++ /dev/null
@@ -1,126 +0,0 @@
-use crate::mini_graph::bang::Bang;
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::Frame;
-
-enum Stage {
-    Idle,
-    Attack,
-    Decay,
-    Sustain,
-    Release,
-}
-
-pub struct ADSR<const N: usize, const C: usize> {
-    attack_time:  f32,
-    decay_time:   f32,
-    sustain_time: f32,     
-    release_time: f32,
-
-    sustain_level: f32,    
-
-    stage: Stage,
-    time_in_stage:    f32,
-    release_start_level: f32,
-
-    sample_rate: f32,
-}
-
-impl<const N: usize, const C: usize> ADSR<N, C> {
-    pub fn new(sample_rate: u32) -> Self {
-        Self {
-            attack_time:   0.1,
-            decay_time:    0.2,
-            sustain_time:  0.0,
-            release_time:  0.2,
-
-            sustain_level: 0.1,
-
-            stage: Stage::Idle,
-            time_in_stage: 0.0,
-            release_start_level: 0.0,
-
-            sample_rate: sample_rate as f32,
-        }
-    }
-
-    fn note_on(&mut self) {
-        self.stage = Stage::Attack;
-        self.time_in_stage = 0.0;
-    }
-
-    fn note_off(&mut self) {
-        let current = self.current_level();
-        self.release_start_level = current;
-        self.stage = Stage::Release;
-        self.time_in_stage = 0.0;
-    }
-
-    fn current_level(&self) -> f32 {
-        match self.stage {
-            Stage::Idle    => 0.0,
-            Stage::Attack  => (self.time_in_stage / self.attack_time).min(1.0),
-            Stage::Decay   => {
-                let t = (self.time_in_stage / self.decay_time).min(1.0);
-                1.0 + t * (self.sustain_level - 1.0) // lerp(1.0, sustain_level, t)
-            }
-            Stage::Sustain => self.sustain_level,
-            Stage::Release => {
-                let t = (self.time_in_stage / self.release_time).min(1.0);
-                self.release_start_level * (1.0 - t) // lerp(release_start, 0.0, t)
-            }
-        }
-    }
-}
-
-impl<const N: usize, const C: usize> AudioNode<N, C> for ADSR<N, C> {
-    fn process(&mut self, inputs: &[Frame<N, C>], output: &mut Frame<N, C>) {
-        let dt = 1.0 / self.sample_rate;
-        let input = inputs[0];
-
-        for n in 0..N {
-            let level = self.current_level();
-
-            for c in 0..C {
-                output[c][n] = input[c][n] * level;
-            }
-
-            self.time_in_stage += dt;
-            match self.stage {
-                Stage::Attack if self.time_in_stage >= self.attack_time => {
-                    self.stage = Stage::Decay;
-                    self.time_in_stage = 0.0;
-                }
-                Stage::Decay if self.time_in_stage >= self.decay_time => {
-                    if self.sustain_time > 0.0 {
-                        self.stage = Stage::Sustain;
-                        self.time_in_stage = 0.0;
-                    } else {
-                        self.stage = Stage::Sustain;
-                    }
-                }
-                Stage::Sustain if self.sustain_time > 0.0
-                    && self.time_in_stage >= self.sustain_time =>
-                {
-                    self.note_off();
-                }
-                Stage::Release if self.time_in_stage >= self.release_time => {
-                    self.stage = Stage::Idle;
-                    self.time_in_stage = 0.0;
-                }
-                _ => {}
-            }
-        }
-    }
-
-    fn handle_bang(&mut self, inputs: &[Bang], _: &mut Bang) {
-        for &bang in inputs {
-            if let Bang::Bang = bang {
-                if matches!(self.stage, Stage::Idle) {
-                    self.note_on();
-                } else {
-                    self.note_off();
-                }
-            }
-        }
-    }
-}
diff --git a/src/nodes/audio/comb_filter.rs b/src/nodes/audio/comb_filter.rs
deleted file mode 100644
index 65cf696..0000000
--- a/src/nodes/audio/comb_filter.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-use std::collections::VecDeque;
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::Frame;
-
-pub struct CombFilter<const N: usize, const C: usize> {
-    ringbufs: [VecDeque<f32>; C],
-    feedback: f32,
-}
-
-impl<const N: usize, const C: usize> CombFilter<N, C>{
-    pub fn new(delay_len: usize, feedback: f32) -> Self {
-        let ringbufs = std::array::from_fn(|_| {
-            let mut buf = VecDeque::with_capacity(delay_len);
-            buf.extend(std::iter::repeat(0.0).take(delay_len));
-            buf
-        });
-        Self { ringbufs, feedback }
-    }
-
-    #[inline(always)]
-    fn tick(&mut self, chan: usize, input: f32) -> f32 {
-        let buf = &mut self.ringbufs[chan];
-        let out = buf.pop_front().unwrap();
-
-        let float_with_feedback = input + self.feedback * out;
-        buf.push_back(float_with_feedback);
-        out
-    }
-}
-
-impl<const N: usize, const C: usize> AudioNode<N, C> for CombFilter<N, C> {
-    #[inline(always)]
-    fn process(&mut self, inputs: &[Frame<N, C>], output: &mut Frame<N, C>) {
-        if self.feedback >= 1.0 {
-           self.feedback = 0.98;
-        }
-        let input = inputs[0];
-        for n in 0..N {
-            for c in 0..C {
-                output[c][n] = self.tick(c, input[c][n]);
-            }
-        }
-    }
-}
diff --git a/src/nodes/audio/delay.rs b/src/nodes/audio/delay.rs
deleted file mode 100644
index 0af734a..0000000
--- a/src/nodes/audio/delay.rs
+++ /dev/null
@@ -1,123 +0,0 @@
-use crate::mini_graph::{buffer::Frame, node::{DelayTapNode, DelayWriteNode}};
-
-/// For now, we are assuming that the delay line is single threaded,
-/// and since we have readers after the writer, we are using unsafe 
-/// as there will not be aliasing reads during writing.
-
-pub fn lerp(v0: f32,  v1: f32, t: f32) -> f32 {
-    (1.0 - t) * v0 + t * v1
-}
-
-#[derive(Clone)]
-pub struct DelayLine<const N: usize, const C: usize> {
-    buffers: [Vec<f32>; C],
-    capacity: usize,
-    write_pos: usize,
-}
-
-impl<const N: usize, const C: usize> DelayLine<N, C> {
-    pub fn new(capacity: usize) -> Self {
-        assert!(capacity >= N);
-        let buffers = std::array::from_fn(|_| vec![0.0; capacity]);
-        Self {
-            buffers,
-            capacity: capacity,
-            write_pos: 0
-        }
-    }
-    #[inline(always)]
-    pub fn get_write_pos(&self) -> &usize {
-        &self.write_pos
-    }
-    #[inline(always)]
-    pub fn write_block(&mut self, block: &Frame<N, C>) {
-        // We're assuming single threaded, with the graph firing in order, so no aliasing writes
-        // Our first writing block is whatever capacity is leftover from the writing position
-        // Our maximum write size is the block N
-        let first_write_size = (self.capacity - self.write_pos).min(N);
-        // Our second write size is whatever leftover from N we still have
-        let second_write_size = N - first_write_size;
-
-        for c in 0..C {
-            let buf = &mut self.buffers[c];
-            buf[self.write_pos..self.write_pos + first_write_size].copy_from_slice(&block[c][0..first_write_size]);
-            if second_write_size > 0 {
-                buf[0..second_write_size].copy_from_slice(&block[c][first_write_size..first_write_size + second_write_size]);
-            }
-        }
-        self.write_pos = (self.write_pos + N) % self.capacity;
-    }
-    // Note: both of these functions use f32 sample indexes, as we allow for interpolated values
-    #[inline(always)]
-    pub fn get_delay_linear_interp(&self, channel: usize, offset: f32) -> f32 { 
-        // Get the remainder of the difference of the write position and fractional sample index we need
-        let read_pos = (self.write_pos as f32 - offset).rem_euclid(self.capacity as f32);
-
-        let pos_floor = read_pos.floor() as usize;
-        let next_sample = (pos_floor + 1) % self.capacity;
-
-        let buffer = &self.buffers[channel];
-
-        lerp(buffer[pos_floor], buffer[next_sample], read_pos - pos_floor as f32)
-    }
-}
-
-pub struct DelayWrite<const N: usize, const C: usize> {
-    name: &'static str,
-    delay_index: usize
-}
-
-impl<const N: usize, const C: usize> DelayWrite<N, C>{
-    pub fn new(name: &'static str, delay_index: usize) -> Self {
-        Self {
-            name,
-            delay_index
-        }
-    }
-}
-
-impl<const N: usize, const C: usize> DelayWriteNode<N, C> for DelayWrite<N, C>{
-    fn process(&mut self, inputs: &[Frame<N, C>], delay_line: &mut DelayLine<N, C>) {
-        if let Some(input) = inputs.get(0){
-            delay_line.write_block(input);
-        }
-    }
-    #[inline(always)]
-    fn get_delay_line_index(&self) -> &usize {
-        &self.delay_index
-    }
-}
-
-pub struct DelayTap<const N: usize, const C: usize> {
-    gain: f32,
-    delay_index: usize,
-    sample_offset: f32, // Tap size, in samples
-
-}
-impl<const N: usize, const C: usize> DelayTap<N, C>{
-    pub fn new(sample_offset: f32, delay_index: usize, gain: f32) -> Self {
-        Self {
-            gain,
-            delay_index,
-            sample_offset
-        }
-    }
-}
-impl<const N: usize, const C: usize> DelayTapNode<N, C> for DelayTap<N, C>{
-    fn process(&mut self, delay_line: &DelayLine<N, C>, output: &mut Frame<N, C>) {
-        for n in 0..N {
-            for c in 0..C {
-                let dynamic_offset = self.sample_offset + (N as f32 - n as f32);
-                output[c][n] = delay_line.get_delay_linear_interp(c, dynamic_offset) * self.gain;
-            }
-        }
-    }
-    fn get_delay_line_index(&self) -> &usize {
-        &self.delay_index
-    }
-}
-
-// Currently single threaded, no multiple aliases, but this needs to be refactored
-unsafe impl<const N: usize, const C: usize> Send for DelayLine<N, C> {}
-unsafe impl<const N: usize, const C: usize> Send for DelayWrite<N, C> {}
-unsafe impl<const N: usize, const C: usize> Send for DelayTap<N, C> {}
\ No newline at end of file
diff --git a/src/nodes/audio/filters.rs b/src/nodes/audio/filters.rs
deleted file mode 100644
index f32cce5..0000000
--- a/src/nodes/audio/filters.rs
+++ /dev/null
@@ -1,232 +0,0 @@
-use std::f32::consts::PI;
-
-use crate::mini_graph::{buffer::Frame, node::AudioNode};
-
-
-#[derive(Copy, Clone)]
-pub enum FilterType {
-    LowPass,
-    BandPass,
-    HighPass,
-    Notch,
-    Peak,
-    AllPass,
-    Bell,
-    LowShelf,
-    HighShelf,
-}
-#[derive(Copy, Clone, Default)]
-struct SvfState {
-    ic1eq: f32,
-    ic2eq: f32
-}
-
-
-#[derive(Copy, Clone, Default)]
-struct SvfCoefficients {
-    a1: f32,
-    a2: f32,
-    a3: f32,
-    m0: f32,
-    m1: f32,
-    m2: f32,
-}
-
-pub struct Svf <const C: usize> {
-    filter_type: FilterType,
-    sample_rate: f32,
-    cutoff: f32,
-    gain: f32,
-    q: f32,
-    // Filter state for each channel
-    filter_state: [SvfState; C],
-    // Filter Coefficeints
-    coefficients: SvfCoefficients
-}
-
-impl<const C: usize> Svf<C> {
-    pub fn new(sample_rate: f32, filter_type: FilterType, cutoff: f32, gain: f32, q: f32) -> Self {
-        let mut new_filter = 
-        Self {
-            sample_rate, 
-            filter_type,
-            cutoff,
-            gain,
-            q,
-            filter_state: [SvfState::default();C],
-            coefficients: SvfCoefficients::default()
-        };
-
-        new_filter.set(filter_type, sample_rate, cutoff, q, gain);
-
-        new_filter
-    }
-    #[inline(always)]
-    pub fn set(&mut self, filter_type: FilterType, sample_rate: f32, cutoff: f32, q: f32, gain: f32){
-        self.filter_type = filter_type;
-        self.sample_rate = sample_rate;
-        self.cutoff = cutoff;
-        self.q = q;
-        self.gain = gain;
-
-        match filter_type {
-            FilterType::LowPass => {
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-                let k = 1.0 / self.q;
-
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 0.0;
-                self.coefficients.m1 = 0.0;
-                self.coefficients.m2 = 1.0;
-            },
-            FilterType::BandPass => {
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-                let k = 1.0 / self.q;
-
-                self.coefficients.a1 = 1.0 / (1.0 + g*(g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g*self.coefficients.a2;
-                self.coefficients.m0 = 0.0;
-                self.coefficients.m1 = 1.0;
-                self.coefficients.m2 = 0.0;
-            },
-            FilterType::HighPass => {
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-                let k = 1.0 / self.q;
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 1.0;
-                self.coefficients.m1 = -k;
-                self.coefficients.m2 = -1.0;
-            }
-            FilterType::BandPass => {
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-                let k = 1.0 / self.q;
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 0.0;
-                self.coefficients.m1 = 1.0;
-                self.coefficients.m2 = 0.0;
-            }
-            FilterType::Notch => {
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-                let k = 1.0 / self.q;
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 1.0;
-                self.coefficients.m1 = -k;
-                self.coefficients.m2 = 0.0;
-            }
-            FilterType::Peak => {
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-
-                let k = 1.0 / self.q;
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 1.0;
-                self.coefficients.m1 = -k;
-                self.coefficients.m2 = -2.0;
-            }
-            FilterType::AllPass => {
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-                let k = 1.0 / self.q;
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 1.0;
-                self.coefficients.m1 = -2.0 * k;
-                self.coefficients.m2 = 0.0;
-            }
-            FilterType::Bell => {
-                let a = f32::powf(
-                    10.0,
-                    self.gain / 40.0,
-                );
-                let g = (PI * self.cutoff / self.sample_rate).tan();
-
-                let k = 1.0 / (self.q * a);
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 1.0;
-                self.coefficients.m1 = k * (a * a - 1.0);
-                self.coefficients.m2 = 0.0;
-            }
-            FilterType::LowShelf => {
-                let a = f32::powf(
-                    10.0,
-                    self.gain / 40.0,
-                );
-                let g = (PI * self.cutoff / self.sample_rate).tan() / f32::sqrt(a);
-                let k = 1.0 / self.q;
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = 1.0;
-                self.coefficients.m1 = k * (a - 1.0);
-                self.coefficients.m2 = a * a - 1.0;
-            }
-            FilterType::HighShelf => {
-                let a = f32::powf(
-                    10.0,
-                    self.gain / 40.0,
-                );
-                let g = (PI * self.cutoff / self.sample_rate).tan() * f32::sqrt(a);
-
-                let k = 1.0 / self.q;
-                self.coefficients.a1 = 1.0 / (1.0 + g * (g + k));
-                self.coefficients.a2 = g * self.coefficients.a1;
-                self.coefficients.a3 = g * self.coefficients.a2;
-                self.coefficients.m0 = a * a;
-                self.coefficients.m1 = k * (1.0 - a) * a;
-                self.coefficients.m2 = 1.0 - a * a;
-            }
-            _ => ()
-        }
-    }
-}
-
-const CUTOFF_EPSILON: f32 = 1e-3;
-
-impl<const N: usize, const C: usize> AudioNode<N, C> for Svf<C>{
-    fn process(&mut self, inputs: &[Frame<N, C>], output: &mut Frame<N, C>) {
-        let input = match inputs.get(0) {
-            Some(input) => input,
-            None => return,
-        };
-        
-        let cutoff = inputs.get(1);
-
-        for n in 0..N {
-            if let Some(cutoff_frame) = cutoff {
-                let new_cutoff = cutoff_frame[0][n];
-                if (new_cutoff - self.cutoff).abs() > CUTOFF_EPSILON {
-                    self.set(self.filter_type, self.sample_rate, new_cutoff, self.q, self.gain);
-                }
-            }
-
-            for c in 0..C {
-                let filter_state = &mut self.filter_state[c];
-
-                let v0 = input[c][n];
-
-                let v3 = v0 - filter_state.ic2eq;
-
-                let v1 = self.coefficients.a1 * filter_state.ic1eq + self.coefficients.a2 * v3;
-
-                let v2 = filter_state.ic2eq + self.coefficients.a2 * filter_state.ic1eq + self.coefficients.a3 * v3;
-                
-                filter_state.ic1eq = 2.0 * v1 - filter_state.ic1eq;
-                filter_state.ic2eq = 2.0 * v2 - filter_state.ic2eq;
-
-                output[c][n] = self.coefficients.m0 * v0 + self.coefficients.m1 * v1 + self.coefficients.m2 * v2;
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/audio/gain.rs b/src/nodes/audio/gain.rs
deleted file mode 100644
index 8ff12a4..0000000
--- a/src/nodes/audio/gain.rs
+++ /dev/null
@@ -1,25 +0,0 @@
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::{Frame};
-
-pub struct Gain<const FRAME_SIZE: usize> {
-    gain: f32 // Arc<AtomicF32> might be more helpful. If you need an atomic f32 there is an easy trick
-}
-impl<const N: usize> Gain<N> {
-    pub fn new(gain: f32) -> Self {
-        Self {
-            gain
-        }
-    }
-}
-impl <const N: usize, const C: usize> AudioNode<N, C> for Gain<N> {
-    #[inline(always)]
-    fn process(&mut self, inputs: &[Frame<N, C>], output: &mut Frame<N, C>){
-        // This node only takes an input of one stereo buffer.
-        let input = inputs[0];
-        for n in 0..N { // For ever sample in our frame size
-            for c in 0..C { // For ever channel in our frame
-                output[c][n] = (input[c][n] * self.gain).clamp(-1.0 , 1.0);
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/audio/gate.rs b/src/nodes/audio/gate.rs
deleted file mode 100644
index ab22e34..0000000
--- a/src/nodes/audio/gate.rs
+++ /dev/null
@@ -1,28 +0,0 @@
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::{Frame};
-
-pub struct Gate {
-    is_open: bool
-}
-impl Gate {
-    pub fn new() -> Self {
-        Self {
-            is_open: false
-        }
-    }
-}
-impl<const C: usize, const N: usize> AudioNode<C, N> for Gate {
-    #[inline(always)]
-    fn process(&mut self, inputs: &[Frame<C, N>], output: &mut Frame<C, N>) {
-        if let Some(input) = inputs.get(0) {
-            if self.is_open {
-                *output = *input;
-            }
-            else {
-                for buf in output.iter_mut() {
-                    buf.fill(0.0);
-                }
-            }
-        }
-    }
-}
diff --git a/src/nodes/audio/hard_clipper.rs b/src/nodes/audio/hard_clipper.rs
deleted file mode 100644
index 3f4f742..0000000
--- a/src/nodes/audio/hard_clipper.rs
+++ /dev/null
@@ -1,26 +0,0 @@
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::{Frame};
-
-pub struct HardClipper<const FRAME_SIZE: usize> {
-    limit: f32,
-}
-impl<const N: usize> HardClipper<N> {
-    pub fn new(limit: f32) -> Self {
-        Self {
-            limit
-        }
-    }
-}
-impl<const N: usize, const C: usize> AudioNode<N,C> for HardClipper<N> {
-    fn process(&mut self, inputs: &[Frame<N, C>], output: &mut Frame<N, C>){
-        if (self.limit > 1.0) {
-            panic!("Invalid limit!!")
-        }
-        let input = inputs[0];
-        for n in 0..N {
-            for c in 0..C { 
-                output[c][n] = input[c][n].clamp(-1.0 * self.limit , self.limit);
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/audio/mixer.rs b/src/nodes/audio/mixer.rs
deleted file mode 100644
index be61bd0..0000000
--- a/src/nodes/audio/mixer.rs
+++ /dev/null
@@ -1,20 +0,0 @@
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::{Frame};
-
-#[derive(Default)]
-pub struct Mixer<const N: usize> {}
-
-impl<const N: usize, const C: usize> AudioNode<N, C> for Mixer<N> {
-    #[inline(always)]
-    fn process(&mut self, inputs: &[Frame<N, C>], output: &mut Frame<N, C>){
-        for n in 0..N {
-            for c in 0..C {
-                let mut sum = 0.0;
-                for input in inputs {
-                    sum += input[c][n]
-                }
-                output[c][n] = (sum / inputs.len() as f32).clamp(-1.0, 1.0);
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/audio/mod.rs b/src/nodes/audio/mod.rs
deleted file mode 100644
index b0fc470..0000000
--- a/src/nodes/audio/mod.rs
+++ /dev/null
@@ -1,10 +0,0 @@
-pub mod adsr;
-pub mod comb_filter;
-pub mod delay;
-pub mod gain;
-pub mod gate;
-pub mod hard_clipper;
-pub mod mixer;
-pub mod osc;
-pub mod filters;
-pub mod sampler;
\ No newline at end of file
diff --git a/src/nodes/audio/osc.rs b/src/nodes/audio/osc.rs
deleted file mode 100644
index 645d4cc..0000000
--- a/src/nodes/audio/osc.rs
+++ /dev/null
@@ -1,86 +0,0 @@
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::{Frame};
-use crate::mini_graph::bang::Bang;
-
-pub enum Wave {
-    SinWave,
-    SawWave,
-    TriangleWave,
-    SquareWave,
-}
-
-pub struct Oscillator<const BUFFER_SIZE: usize> {
-    freq: f32,
-    sample_rate: f32,
-    phase: f32,
-    wave: Wave
-}
-
-impl<const N: usize> Oscillator<N> {
-    pub fn new(freq: f32, sample_rate: u32, phase: f32, wave: Wave) -> Self {
-        Self {
-            freq,
-            sample_rate: sample_rate as f32,
-            phase,
-            wave
-        }
-    }
-    pub fn set_wave_form(&mut self, wave: Wave){
-        self.wave = wave;
-    }
-    #[inline(always)]
-    fn tick_osc(&mut self) -> f32 {
-        let sample = match self.wave {
-            Wave::SinWave => sin_amp_from_phase(&self.phase),
-            Wave::SawWave => saw_amp_from_phase(&self.phase),
-            Wave::SquareWave => square_amp_from_phase(&self.phase),
-            Wave::TriangleWave => triangle_amp_from_phase(&self.phase),
-        };
-        self.phase += self.freq / self.sample_rate as f32;
-        self.phase -= (self.phase >= 1.0) as u32 as f32; 
-        sample
-    }
-}
-impl<const N: usize, const C: usize> AudioNode<N, C> for Oscillator<N> {
-    #[inline(always)]
-    fn process(&mut self, _: &[Frame<N, C>], output: &mut Frame<N, C>){
-        for i in 0..N {
-            let sample = self.tick_osc();
-            for buf in output.iter_mut() {
-                buf[i] = sample;
-            }
-        }
-    }
-    
-    fn handle_bang(&mut self, inputs: &[Bang], _: &mut Bang) {
-        if let Some(bang) = inputs.get(0) {
-            match bang {
-                Bang::BangF32(freq) => self.freq = *freq,
-                _ => ()
-            }
-        }
-    }
-}
-
-#[inline(always)]
-fn sin_amp_from_phase(phase: &f32) -> f32 {
-    (*phase * 2.0 * std::f32::consts::PI).sin()
-}
-
-#[inline(always)]
-fn saw_amp_from_phase(phase: &f32) -> f32 {
-    *phase * 2.0 - 1.0
-}
-
-#[inline(always)]
-fn triangle_amp_from_phase(phase: &f32) -> f32 {
-    2.0 * ((-1.0 + (*phase * 2.0)).abs() - 0.5)
-}
-
-#[inline(always)]
-fn square_amp_from_phase(phase: &f32) -> f32 {
-    match *phase <= 0.5 {
-        true => 1.0,
-        false => -1.0,
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/audio/sampler.rs b/src/nodes/audio/sampler.rs
deleted file mode 100644
index ce57c7d..0000000
--- a/src/nodes/audio/sampler.rs
+++ /dev/null
@@ -1,85 +0,0 @@
-use std::{path::Path, sync::Arc};
-
-use arc_swap::ArcSwapOption;
-use assert_no_alloc::permit_alloc;
-
-use crate::{mini_graph::{buffer::Frame, node::{IONode}}, utils::load_sample::decode_with_ffmpeg};
-
-
-pub enum AudioSampleError {
-    PathNotFound,
-    FailedDecoding
-}
-
-pub struct AudioSampleBackend<const C: usize> {
-    data: Arc<ArcSwapOption<[Vec<f32>; C]>>
-}
-impl<const C: usize> AudioSampleBackend<C>{
-    pub fn new( data: Arc<ArcSwapOption<[Vec<f32>; C]>>) -> Self {
-        Self {
-           data
-        }
-    }
-    pub fn load_file(&self, path: &str) -> Result<(), AudioSampleError>{
-        match decode_with_ffmpeg(path) {
-            Ok(decoded) => {
-                self.data.store(Some(decoded));
-                Ok(())
-            },
-            Err(_) => Err(AudioSampleError::FailedDecoding) //TODO: Some logging or something?
-        } 
-    }
-}
-
-pub struct Sampler<const N: usize, const C: usize> {
-    data: Arc<ArcSwapOption<[Vec<f32>; C]>>,
-    read_pos: usize,
-    is_looping: bool
-}
-
-impl<const N: usize, const C: usize> Sampler<N, C> {
-    fn new(data: Arc<ArcSwapOption<[Vec<f32>; C]>>, is_looping: bool) -> Self {
-        Self {
-            data,
-            read_pos: 0 as usize,
-            is_looping
-        }
-    }
-}
-
-impl<const N: usize, const C: usize> IONode<N, C> for Sampler<N, C> {
-    fn process(&mut self, output: &mut Frame<N, C>) {
-        permit_alloc(|| { // 128 bytes allocated in the load_full. Can we do better?
-            match self.data.load_full() {
-                Some(buf) => {
-                    let len = buf[0].len();
-                    for n in 0..N {
-                        let i = self.read_pos + n;
-                        for c in 0..C {
-                            output[c][n] = if i < len {
-                                buf[c][i]
-                            } else if self.is_looping {
-                                buf[c][i % len]
-                            } else { 0.0 };
-                        }
-                    }
-                    self.read_pos = if self.is_looping {
-                        (self.read_pos + N) % len // If we're looping, wrap around
-                    } else {
-                        (self.read_pos + N).min(len) // If we're not looping, cap at the end
-                    };
-                },
-                None => ()
-            }
-        })
-    }
-}
-
-// TODO: Can we find some minimum size so we can call with_capacity instead of growing dynamically?
-pub fn build_audio_sampler<const N: usize, const C: usize>(is_looping: bool) -> (Sampler<N, C>, AudioSampleBackend<C>) {
-    let data = Arc::new(ArcSwapOption::new(None));
-    let sampler = Sampler::new(Arc::clone(&data), is_looping);
-    let backend = AudioSampleBackend::new(data);
-
-    (sampler, backend)
-}
\ No newline at end of file
diff --git a/src/nodes/control/clock.rs b/src/nodes/control/clock.rs
deleted file mode 100644
index f4b4a43..0000000
--- a/src/nodes/control/clock.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::bang::Bang;
-
-pub struct Clock<const N: usize, const C: usize> {
-    sample_rate: u32,
-    is_ticking: bool,
-    tick_period_samples: u64,
-    samples_accum: u64,
-}
-
-impl<const N: usize, const C: usize> Clock<N, C> {
-    pub fn new(sample_rate: u32, clock_rate: std::time::Duration) -> Self {
-        let period_secs = clock_rate.as_secs_f32();
-        let tick_period_samples = (period_secs * sample_rate as f32).round() as u64;
-
-        Self {
-            sample_rate,
-            is_ticking: true,
-            tick_period_samples,
-            samples_accum: tick_period_samples, // so this fires immediately
-        }
-    }
-}
-
-impl<const N: usize, const C: usize> AudioNode<N, C> for Clock<N, C> {
-    fn handle_bang(&mut self, inputs: &[Bang], output: &mut Bang) {
-        if let Some(b) = inputs.get(0) {
-            match b {
-                Bang::Bang => self.is_ticking = !self.is_ticking,
-                Bang::BangBool(val) => self.is_ticking = *val,
-                _ => (),
-            }
-        }
-        if let Some(b) = inputs.get(1) {
-            match b {
-                Bang::BangF32(val) => {
-                    let new_period = (*val * self.sample_rate as f32).round() as u64;
-                    self.tick_period_samples = new_period;
-                }
-                Bang::BangU32(val) => {
-                    let new_period = (*val as f32 * self.sample_rate as f32).round() as u64;
-                    self.tick_period_samples = new_period;
-                }
-                _ => (),
-            }
-        }
-
-        if !self.is_ticking {
-            *output = Bang::Empty;
-            return;
-        }
-
-        self.samples_accum += N as u64;
-        
-        if self.samples_accum >= self.tick_period_samples {
-            *output = Bang::Bang;
-            self.samples_accum -= self.tick_period_samples;
-        } else {
-            *output = Bang::Empty;
-        }
-    }
-}
diff --git a/src/nodes/control/iter.rs b/src/nodes/control/iter.rs
deleted file mode 100644
index fc6d424..0000000
--- a/src/nodes/control/iter.rs
+++ /dev/null
@@ -1,31 +0,0 @@
-use crate::mini_graph::{bang::Bang, node::AudioNode};
-
-pub struct BangIter<'a, const C: usize, const N: usize> {
-    position: usize,
-    values: &'a[Bang],
-}
-impl<'a, const C: usize, const N: usize> BangIter<'a, C, N> {
-    pub fn new(values: &'a[Bang]) -> Self {
-        Self {
-            position: 0,
-            values
-        }
-    }
-}
-impl<'a, const C: usize, const N: usize> AudioNode<C, N> for BangIter<'a, C, N>{
-    fn handle_bang(&mut self, inputs: &[Bang], output: &mut Bang) {
-        for input in inputs {
-            if *input == Bang::Bang {
-                *output = self.values[self.position];
-                if self.position < self.values.len() - 1 {
-                    self.position += 1;
-                }
-                else {
-                    self.position = 0;
-                }
-                return
-            }
-        }
-
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/control/lfo.rs b/src/nodes/control/lfo.rs
deleted file mode 100644
index 1795ccd..0000000
--- a/src/nodes/control/lfo.rs
+++ /dev/null
@@ -1,41 +0,0 @@
-use std::f32::consts::PI;
-
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::buffer::Frame;
-
-pub struct Lfo {
-    freq: f32,
-    amp: f32,
-    offset: f32,
-    phase: f32,
-    sample_rate: f32
-}
-impl Lfo {
-    pub fn new(freq: f32, offset: f32, amp: f32, phase: f32, sample_rate: f32) -> Self {
-        Self {
-            freq,
-            amp,
-            offset,
-            phase,
-            sample_rate
-        }
-    }
-    #[inline(always)]
-    fn tick(&mut self) -> f32 {
-        let sample = (self.phase * 2.0 * PI).sin() * self.amp + self.offset;
-        self.phase += self.freq / self.sample_rate;
-
-        sample
-    }
-}
-
-impl<const N: usize, const C: usize> AudioNode<N, C> for Lfo {
-    fn process(&mut self, _: &[Frame<N, C>], output: &mut Frame<N, C>) {
-        for n in 0..N {
-            let sample = self.tick();
-            for c in 0..C {
-                output[c][n] = sample;
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/control/log.rs b/src/nodes/control/log.rs
deleted file mode 100644
index cee2f01..0000000
--- a/src/nodes/control/log.rs
+++ /dev/null
@@ -1,14 +0,0 @@
-use crate::mini_graph::bang::Bang;
-use crate::mini_graph::node::AudioNode;
-
-pub struct Log<const N: usize, const C: usize> {}
-impl<const N: usize, const C: usize>  AudioNode<N,C> for Log<N, C>{
-    fn handle_bang(&mut self, inputs: &[Bang], _: &mut Bang) {
-        if let Some(bang) = inputs.get(0){
-            match bang {
-                Bang::Empty => (),
-                item => println!("{:?}", item)
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/nodes/control/midi_to_f.rs b/src/nodes/control/midi_to_f.rs
deleted file mode 100644
index 1ce5810..0000000
--- a/src/nodes/control/midi_to_f.rs
+++ /dev/null
@@ -1,59 +0,0 @@
-// For now, we are just using u8 values. Maybe Enums for note names in the future
-
-use crate::mini_graph::node::AudioNode;
-use crate::mini_graph::bang::{Bang};
-
-pub struct MidiToF {}
-impl MidiToF {
-    #[inline(always)]
-    fn midi_to_f(&self, midi: u8) -> f32 {
-      440.0 * (f32::powf(2.0, (midi as f32 - 69.0) / 12.0) )
-    }
-}
-impl<const N: usize, const C: usize> AudioNode<N, C> for MidiToF {
-    fn handle_bang(&mut self, inputs: &[Bang], output: &mut Bang) {
-        if let Some(input) = inputs.get(0) {
-            match *input {
-                Bang::BangMidi(msg) => {
-                    *output = Bang::BangF32(self.midi_to_f(msg.key))
-                },
-                _ => ()
-            } 
-        }
-    }
-}
-
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    const EPS: f32 = 0.01;
-
-    fn approx_eq(a: f32, b: f32) -> bool {
-        (a - b).abs() < EPS
-    }
-
-    #[test]
-    fn test_known_notes() {
-        let node = MidiToF {};
-        let cases = [
-            (0u8,    8.1758),     // C-1
-            (32u8, 51.91),        // G#1
-            (69u8, 440.0000),     // A4
-            (103u8, 3135.96),      // G7
-            (127u8, 12543.85)     // G9
-        ];
-
-        for &(midi, expected) in &cases {
-            let freq = node.midi_to_f(midi);
-            assert!(
-                approx_eq(freq, expected),
-                "midi_to_f({}) = {}, expected ~{}",
-                midi,
-                freq,
-                expected
-            );
-        }
-    }
-}
diff --git a/src/nodes/control/mod.rs b/src/nodes/control/mod.rs
deleted file mode 100644
index c174f6b..0000000
--- a/src/nodes/control/mod.rs
+++ /dev/null
@@ -1,6 +0,0 @@
-pub mod clock;
-pub mod iter;
-pub mod log;
-pub mod midi_to_f;
-pub mod lfo;
-pub mod signal;
\ No newline at end of file
diff --git a/src/nodes/control/signal.rs b/src/nodes/control/signal.rs
deleted file mode 100644
index 39dc147..0000000
--- a/src/nodes/control/signal.rs
+++ /dev/null
@@ -1,62 +0,0 @@
-use std::sync::Arc;
-use portable_atomic::{AtomicF32, Ordering::{Acquire, Release}};
-
-use crate::mini_graph::{buffer::Frame, node::AudioNode};
-
-pub enum ParamError {
-    InvalidRange
-}
-
-#[derive(Clone)]
-pub struct Param {
-    min: f32,
-    max: f32,
-    val: Arc<AtomicF32>
-}
-
-impl Param {
-    pub fn new(initial: Arc<AtomicF32>, min: f32, max: f32) -> Self {
-        Self {
-            val: initial,
-            min,
-            max
-        }
-    }
-    pub fn set(&self, new_val: f32) -> Result<(), ParamError>{
-        if new_val > self.max || new_val < self.min {
-            return Err(ParamError::InvalidRange);
-        }
-        self.val.store(new_val, Release);
-        return Ok(())
-    }
-    pub fn get(&self) -> f32 {
-        self.val.load(Acquire)
-    }
-}
-
-pub struct Signal {
-    val: Arc<AtomicF32>
-}
-impl Signal {
-    pub fn from(initial: Arc<AtomicF32>) -> Self {
-        Self { val: initial }
-    }
-}
-impl<const N: usize, const C: usize> AudioNode<N, C> for Signal {
-    fn process(&mut self, _: &[Frame<N, C>], output: &mut Frame<N, C>) {
-        let value = self.val.load(Acquire);
-        for n in 0..N {
-            for c in 0..C {
-                output[c][n] = value;
-            }
-        }
-    }
-}
-
-pub fn build_signal(min: f32, max: f32, initial: f32) -> (Signal, Param){
-    let val = Arc::new(AtomicF32::new(initial));
-    let param = Param::new(val.clone(), min, max);
-    let signal_node = Signal::from(val);
-
-    (signal_node, param)
-}
\ No newline at end of file
diff --git a/src/nodes/mod.rs b/src/nodes/mod.rs
deleted file mode 100644
index f717eac..0000000
--- a/src/nodes/mod.rs
+++ /dev/null
@@ -1,2 +0,0 @@
-pub mod audio;
-pub mod control;
\ No newline at end of file
diff --git a/src/utils/load_sample.rs b/src/utils/load_sample.rs
deleted file mode 100644
index 62c65fa..0000000
--- a/src/utils/load_sample.rs
+++ /dev/null
@@ -1,44 +0,0 @@
-use std::process::{Command, Stdio};
-use std::io::{Read, BufReader};
-use std::sync::Arc;
-
-pub fn decode_with_ffmpeg<const C: usize>(path: &str) -> std::io::Result<Arc<[Vec<f32>; C]>> {
-    // ffmpeg command:
-    // -i <file> : input file
-    // -f f32le  : output format: 32-bit float, little-endian
-    // -ac <ch>  : number of channels
-    // -acodec pcm_f32le : codec to use
-    // pipe:1    : write to stdout
-    let mut child = Command::new("ffmpeg")
-        .args([
-            "-i", path,
-            "-f", "f32le",
-            "-ac", &C.to_string(),
-            "-acodec", "pcm_f32le",
-            "pipe:1"
-        ])
-        .stdout(Stdio::piped())
-        .stderr(Stdio::null()) // silence ffmpeg logging
-        .spawn()?;
-
-    let stdout = child.stdout.take().unwrap();
-    let mut reader = BufReader::new(stdout);
-
-    // Prepare per-channel storage
-    let mut per_channel = [const { Vec::<f32>::new() }; C];
-
-    let mut buf = [0u8; 4]; // one f32 sample
-    let mut channel_idx = 0;
-
-    while reader.read_exact(&mut buf).is_ok() {
-        let sample = f32::from_le_bytes(buf);
-        per_channel[channel_idx].push(sample);
-
-        channel_idx += 1;
-        if channel_idx == C {
-            channel_idx = 0;
-        }
-    }
-
-    Ok(Arc::new(per_channel)) // We return this with an Arc, as it's still a small allocation if done elsewhere
-}
\ No newline at end of file
diff --git a/src/utils/mod.rs b/src/utils/mod.rs
deleted file mode 100644
index 385bd25..0000000
--- a/src/utils/mod.rs
+++ /dev/null
@@ -1 +0,0 @@
-pub mod load_sample;
\ No newline at end of file
